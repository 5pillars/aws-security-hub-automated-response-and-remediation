// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`Global Roles Stack 1`] = `
Object {
  "Description": "test;",
  "Parameters": Object {
    "SecHubAdminAccount": Object {
      "AllowedPattern": "\\\\d{12}",
      "Description": "Admin account number",
      "Type": "String",
    },
  },
  "Resources": Object {
    "OrchestratorMemberRoleMemberAccountRoleBE9AD9D5": Object {
      "Metadata": Object {
        "cfn_nag": Object {
          "rules_to_suppress": Array [
            Object {
              "id": "W11",
              "reason": "Resource * is required due to the administrative nature of the solution.",
            },
            Object {
              "id": "W28",
              "reason": "Static names chosen intentionally to provide integration in cross-account permissions",
            },
          ],
        },
      },
      "Properties": Object {
        "AssumeRolePolicyDocument": Object {
          "Statement": Array [
            Object {
              "Action": "sts:AssumeRole",
              "Effect": "Allow",
              "Principal": Object {
                "AWS": Object {
                  "Fn::Join": Array [
                    "",
                    Array [
                      "arn:",
                      Object {
                        "Ref": "AWS::Partition",
                      },
                      ":iam::",
                      Object {
                        "Ref": "SecHubAdminAccount",
                      },
                      ":role/SO0111-SHARR-Orchestrator-Admin",
                    ],
                  ],
                },
                "Service": "ssm.amazonaws.com",
              },
            },
          ],
          "Version": "2012-10-17",
        },
        "Policies": Array [
          Object {
            "PolicyDocument": Object {
              "Statement": Array [
                Object {
                  "Action": Array [
                    "iam:PassRole",
                    "iam:GetRole",
                  ],
                  "Effect": "Allow",
                  "Resource": Object {
                    "Fn::Join": Array [
                      "",
                      Array [
                        "arn:",
                        Object {
                          "Ref": "AWS::Partition",
                        },
                        ":iam::",
                        Object {
                          "Ref": "AWS::AccountId",
                        },
                        ":role/SO0111-*",
                      ],
                    ],
                  },
                },
                Object {
                  "Action": Array [
                    "ssm:DescribeAutomationExecutions",
                    "ssm:DescribeDocument",
                    "ssm:GetParameters",
                  ],
                  "Effect": "Allow",
                  "Resource": Object {
                    "Fn::Join": Array [
                      "",
                      Array [
                        "arn:",
                        Object {
                          "Ref": "AWS::Partition",
                        },
                        ":ssm:*:*:*",
                      ],
                    ],
                  },
                },
                Object {
                  "Action": Array [
                    "ssm:StartAutomationExecution",
                    "ssm:GetAutomationExecution",
                  ],
                  "Effect": "Allow",
                  "Resource": Array [
                    Object {
                      "Fn::Join": Array [
                        "",
                        Array [
                          "arn:",
                          Object {
                            "Ref": "AWS::Partition",
                          },
                          ":ssm:*:",
                          Object {
                            "Ref": "AWS::AccountId",
                          },
                          ":document/SHARR-*",
                        ],
                      ],
                    },
                    Object {
                      "Fn::Join": Array [
                        "",
                        Array [
                          "arn:",
                          Object {
                            "Ref": "AWS::Partition",
                          },
                          ":ssm:*:",
                          Object {
                            "Ref": "AWS::AccountId",
                          },
                          ":automation-definition/*",
                        ],
                      ],
                    },
                    Object {
                      "Fn::Join": Array [
                        "",
                        Array [
                          "arn:",
                          Object {
                            "Ref": "AWS::Partition",
                          },
                          ":ssm:*::automation-definition/*",
                        ],
                      ],
                    },
                    Object {
                      "Fn::Join": Array [
                        "",
                        Array [
                          "arn:",
                          Object {
                            "Ref": "AWS::Partition",
                          },
                          ":ssm:*:",
                          Object {
                            "Ref": "AWS::AccountId",
                          },
                          ":automation-execution/*",
                        ],
                      ],
                    },
                  ],
                },
                Object {
                  "Action": Array [
                    "cloudwatch:PutMetricData",
                    "securityhub:BatchUpdateFindings",
                  ],
                  "Effect": "Allow",
                  "Resource": "*",
                },
              ],
              "Version": "2012-10-17",
            },
            "PolicyName": "member_orchestrator",
          },
        ],
        "RoleName": "SO0111-SHARR-Orchestrator-Member",
      },
      "Type": "AWS::IAM::Role",
    },
  },
}
`;

exports[`Regional Documents 1`] = `
Object {
  "Description": "test;",
  "Resources": Object {
    "SHARRConfigureS3BucketPublicAccessBlockAutomationDocumentD9BFB480": Object {
      "Properties": Object {
        "Content": Object {
          "assumeRole": "{{ AutomationAssumeRole }}",
          "description": "### Document Name - AWSConfigRemediation-ConfigureS3BucketPublicAccessBlock

## What does this document do?
This document is used to create or modify the PublicAccessBlock configuration for an Amazon S3 bucket.

## Input Parameters
* BucketName: (Required) Name of the S3 bucket (not the ARN).
* RestrictPublicBuckets: (Optional) Specifies whether Amazon S3 should restrict public bucket policies for this bucket. Setting this element to TRUE restricts access to this bucket to only AWS services and authorized users within this account if the bucket has a public policy.
  * Default: \\"true\\"
* BlockPublicAcls: (Optional) Specifies whether Amazon S3 should block public access control lists (ACLs) for this bucket and objects in this bucket.
  * Default: \\"true\\"
* IgnorePublicAcls: (Optional) Specifies whether Amazon S3 should ignore public ACLs for this bucket and objects in this bucket. Setting this element to TRUE causes Amazon S3 to ignore all public ACLs on this bucket and objects in this bucket.
  * Default: \\"true\\"
* BlockPublicPolicy: (Optional) Specifies whether Amazon S3 should block public bucket policies for this bucket. Setting this element to TRUE causes Amazon S3 to reject calls to PUT Bucket policy if the specified bucket policy allows public access.
  * Default: \\"true\\"
* AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.

## Output Parameters
* GetBucketPublicAccessBlock.Output - JSON formatted response from the GetPublicAccessBlock API call

## Note: this is a local copy of the AWS-owned document to enable support in aws-cn and aws-us-gov partitions.
",
          "mainSteps": Array [
            Object {
              "action": "aws:executeAwsApi",
              "description": "## PutBucketPublicAccessBlock
Creates or modifies the PublicAccessBlock configuration for a S3 Bucket.
",
              "inputs": Object {
                "Api": "PutPublicAccessBlock",
                "Bucket": "{{BucketName}}",
                "PublicAccessBlockConfiguration": Object {
                  "BlockPublicAcls": "{{ BlockPublicAcls }}",
                  "BlockPublicPolicy": "{{ BlockPublicPolicy }}",
                  "IgnorePublicAcls": "{{ IgnorePublicAcls }}",
                  "RestrictPublicBuckets": "{{ RestrictPublicBuckets }}",
                },
                "Service": "s3",
              },
              "isCritical": true,
              "isEnd": false,
              "maxAttempts": 2,
              "name": "PutBucketPublicAccessBlock",
              "timeoutSeconds": 600,
            },
            Object {
              "action": "aws:executeScript",
              "description": "## GetBucketPublicAccessBlock
Retrieves the S3 PublicAccessBlock configuration for a S3 Bucket.
## Outputs
* Output: JSON formatted response from the GetPublicAccessBlock API call.
",
              "inputs": Object {
                "Handler": "validate_s3_bucket_publicaccessblock",
                "InputPayload": Object {
                  "BlockPublicAcls": "{{ BlockPublicAcls }}",
                  "BlockPublicPolicy": "{{ BlockPublicPolicy }}",
                  "Bucket": "{{BucketName}}",
                  "IgnorePublicAcls": "{{ IgnorePublicAcls }}",
                  "RestrictPublicBuckets": "{{ RestrictPublicBuckets }}",
                },
                "Runtime": "python3.7",
                "Script": "import boto3

def validate_s3_bucket_publicaccessblock(event, context):
  s3_client = boto3.client(\\"s3\\")
  bucket = event[\\"Bucket\\"]
  restrict_public_buckets = event[\\"RestrictPublicBuckets\\"]
  block_public_acls = event[\\"BlockPublicAcls\\"]
  ignore_public_acls = event[\\"IgnorePublicAcls\\"]
  block_public_policy = event[\\"BlockPublicPolicy\\"]

  output = s3_client.get_public_access_block(Bucket=bucket)
  updated_block_acl = output[\\"PublicAccessBlockConfiguration\\"][\\"BlockPublicAcls\\"]
  updated_ignore_acl = output[\\"PublicAccessBlockConfiguration\\"][\\"IgnorePublicAcls\\"]
  updated_block_policy = output[\\"PublicAccessBlockConfiguration\\"][\\"BlockPublicPolicy\\"]
  updated_restrict_buckets = output[\\"PublicAccessBlockConfiguration\\"][\\"RestrictPublicBuckets\\"]

  if updated_block_acl == block_public_acls and updated_ignore_acl == ignore_public_acls \\\\
  and updated_block_policy == block_public_policy and updated_restrict_buckets == restrict_public_buckets:
    return {
      \\"output\\":
        {
          \\"message\\": \\"Bucket public access block configuration successfully set.\\",
          \\"configuration\\": output[\\"PublicAccessBlockConfiguration\\"]
        }
    }
  else:
      info = \\"CONFIGURATION VALUES DO NOT MATCH WITH PARAMETERS PROVIDED VALUES RestrictPublicBuckets: {}, BlockPublicAcls: {}, IgnorePublicAcls: {}, BlockPublicPolicy: {}\\".format(
                restrict_public_buckets,
                block_public_acls,
                ignore_public_acls,
                block_public_policy
              )
      raise Exception(info)",
              },
              "isCritical": true,
              "isEnd": true,
              "name": "GetBucketPublicAccessBlock",
              "outputs": Array [
                Object {
                  "Name": "Output",
                  "Selector": "$.Payload.output",
                  "Type": "StringMap",
                },
              ],
              "timeoutSeconds": 600,
            },
          ],
          "outputs": Array [
            "GetBucketPublicAccessBlock.Output",
          ],
          "parameters": Object {
            "AutomationAssumeRole": Object {
              "allowedPattern": "^arn:(aws[a-zA-Z-]*)?:iam::\\\\d{12}:role/[\\\\w+=,.@-]+",
              "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
              "type": "String",
            },
            "BlockPublicAcls": Object {
              "allowedValues": Array [
                true,
                false,
              ],
              "default": true,
              "description": "(Optional) Specifies whether Amazon S3 should block public access control lists (ACLs) for this bucket and objects in this bucket.",
              "type": "Boolean",
            },
            "BlockPublicPolicy": Object {
              "allowedValues": Array [
                true,
                false,
              ],
              "default": true,
              "description": "(Optional) Specifies whether Amazon S3 should block public bucket policies for this bucket. Setting this element to TRUE causes Amazon S3 to reject calls to PUT Bucket policy if the specified bucket policy allows public access.",
              "type": "Boolean",
            },
            "BucketName": Object {
              "allowedPattern": "(?=^.{3,63}$)(?!^(\\\\d+\\\\.)+\\\\d+$)(^(([a-z0-9]|[a-z0-9][a-z0-9\\\\-]*[a-z0-9])\\\\.)*([a-z0-9]|[a-z0-9][a-z0-9\\\\-]*[a-z0-9])$)",
              "description": "(Required) The bucket name (not the ARN).",
              "type": "String",
            },
            "IgnorePublicAcls": Object {
              "allowedValues": Array [
                true,
                false,
              ],
              "default": true,
              "description": "(Optional) Specifies whether Amazon S3 should ignore public ACLs for this bucket and objects in this bucket. Setting this element to TRUE causes Amazon S3 to ignore all public ACLs on this bucket and objects in this bucket.",
              "type": "Boolean",
            },
            "RestrictPublicBuckets": Object {
              "allowedValues": Array [
                true,
                false,
              ],
              "default": true,
              "description": "(Optional) Specifies whether Amazon S3 should restrict public bucket policies for this bucket. Setting this element to TRUE restricts access to this bucket to only AWS services and authorized users within this account if the bucket has a public policy.",
              "type": "Boolean",
            },
          },
          "schemaVersion": "0.3",
        },
        "DocumentType": "Automation",
        "Name": "SHARR-ConfigureS3BucketPublicAccessBlock",
      },
      "Type": "AWS::SSM::Document",
    },
    "SHARRConfigureS3PublicAccessBlockAutomationDocumentA2255F0A": Object {
      "Properties": Object {
        "Content": Object {
          "assumeRole": "{{ AutomationAssumeRole }}",
          "description": "### Document Name - AWSConfigRemediation-ConfigureS3PublicAccessBlock

## What does this document do?
This document is used to create or modify the S3 [PublicAccessBlock](https://docs.aws.amazon.com/AmazonS3/latest/dev/access-control-block-public-access.html#access-control-block-public-access-options) configuration for an AWS account.

## Input Parameters
* AccountId: (Required) Account ID of the account for which the S3 Account Public Access Block is to be configured.
* RestrictPublicBuckets: (Optional) Specifies whether Amazon S3 should restrict public bucket policies for buckets in this account. Setting this element to TRUE restricts access to buckets with public policies to only AWS services and authorized users within this account.
  * Default: \\"true\\"
* BlockPublicAcls: (Optional) Specifies whether Amazon S3 should block public access control lists (ACLs) for buckets in this account.
  * Default: \\"true\\"
* IgnorePublicAcls: (Optional) Specifies whether Amazon S3 should ignore public ACLs for buckets in this account. Setting this element to TRUE causes Amazon S3 to ignore all public ACLs on buckets in this account and any objects that they contain.
  * Default: \\"true\\"
* BlockPublicPolicy: (Optional) Specifies whether Amazon S3 should block public bucket policies for buckets in this account. Setting this element to TRUE causes Amazon S3 to reject calls to PUT Bucket policy if the specified bucket policy allows public access.
  * Default: \\"true\\"
* AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.

## Output Parameters
* GetPublicAccessBlock.Output - JSON formatted response from the GetPublicAccessBlock API call.
",
          "mainSteps": Array [
            Object {
              "action": "aws:executeAwsApi",
              "description": "## PutAccountPublicAccessBlock
Creates or modifies the S3 PublicAccessBlock configuration for an AWS account.
",
              "inputs": Object {
                "AccountId": "{{ AccountId }}",
                "Api": "PutPublicAccessBlock",
                "PublicAccessBlockConfiguration": Object {
                  "BlockPublicAcls": "{{ BlockPublicAcls }}",
                  "BlockPublicPolicy": "{{ BlockPublicPolicy }}",
                  "IgnorePublicAcls": "{{ IgnorePublicAcls }}",
                  "RestrictPublicBuckets": "{{ RestrictPublicBuckets }}",
                },
                "Service": "s3control",
              },
              "isEnd": false,
              "name": "PutAccountPublicAccessBlock",
              "outputs": Array [
                Object {
                  "Name": "PutAccountPublicAccessBlockResponse",
                  "Selector": "$",
                  "Type": "StringMap",
                },
              ],
              "timeoutSeconds": 600,
            },
            Object {
              "action": "aws:executeScript",
              "description": "## GetPublicAccessBlock
Retrieves the S3 PublicAccessBlock configuration for an AWS account.
## Outputs
* Output: JSON formatted response from the GetPublicAccessBlock API call.
",
              "inputs": Object {
                "Handler": "handler",
                "InputPayload": Object {
                  "AccountId": "{{ AccountId }}",
                  "BlockPublicAcls": "{{ BlockPublicAcls }}",
                  "BlockPublicPolicy": "{{ BlockPublicPolicy }}",
                  "IgnorePublicAcls": "{{ IgnorePublicAcls }}",
                  "RestrictPublicBuckets": "{{ RestrictPublicBuckets }}",
                },
                "Runtime": "python3.7",
                "Script": "import boto3
from time import sleep

def verify_s3_public_access_block(account_id, restrict_public_buckets, block_public_acls, ignore_public_acls, block_public_policy):
   s3control_client = boto3.client('s3control')
   wait_time = 30
   max_time = 480
   retry_count = 1
   max_retries = max_time/wait_time
   while retry_count <= max_retries:
       sleep(wait_time)
       retry_count = retry_count + 1
       get_public_access_response = s3control_client.get_public_access_block(AccountId=account_id)
       updated_block_acl = get_public_access_response['PublicAccessBlockConfiguration']['BlockPublicAcls']
       updated_ignore_acl = get_public_access_response['PublicAccessBlockConfiguration']['IgnorePublicAcls']
       updated_block_policy = get_public_access_response['PublicAccessBlockConfiguration']['BlockPublicPolicy']
       updated_restrict_buckets = get_public_access_response['PublicAccessBlockConfiguration']['RestrictPublicBuckets']
       if updated_block_acl == block_public_acls and updated_ignore_acl == ignore_public_acls \\\\
                 and updated_block_policy == block_public_policy and updated_restrict_buckets == restrict_public_buckets:
                   return {
                       \\"output\\": {
                           \\"message\\": \\"Verification successful. S3 Public Access Block Updated.\\",
                           \\"HTTPResponse\\": get_public_access_response[\\"PublicAccessBlockConfiguration\\"]
                       },
                   }
   raise Exception(
         \\"VERFICATION FAILED. S3 GetPublicAccessBlock CONFIGURATION VALUES \\"
         \\"DO NOT MATCH WITH PARAMETERS PROVIDED VALUES \\"
         \\"RestrictPublicBuckets: {}, BlockPublicAcls: {}, IgnorePublicAcls: {}, BlockPublicPolicy: {}\\"
         .format(updated_restrict_buckets, updated_block_acl, updated_ignore_acl, updated_block_policy)
   )

def handler(event, context):
  account_id = event[\\"AccountId\\"]
  restrict_public_buckets = event[\\"RestrictPublicBuckets\\"]
  block_public_acls = event[\\"BlockPublicAcls\\"]
  ignore_public_acls = event[\\"IgnorePublicAcls\\"]
  block_public_policy = event[\\"BlockPublicPolicy\\"]
  return verify_s3_public_access_block(account_id, restrict_public_buckets, block_public_acls, ignore_public_acls, block_public_policy)",
              },
              "isEnd": true,
              "name": "GetPublicAccessBlock",
              "outputs": Array [
                Object {
                  "Name": "Output",
                  "Selector": "$.Payload.output",
                  "Type": "StringMap",
                },
              ],
              "timeoutSeconds": 600,
            },
          ],
          "outputs": Array [
            "GetPublicAccessBlock.Output",
          ],
          "parameters": Object {
            "AccountId": Object {
              "allowedPattern": "^\\\\d{12}$",
              "description": "(Required) The account ID for the AWS account whose PublicAccessBlock configuration you want to set.",
              "type": "String",
            },
            "AutomationAssumeRole": Object {
              "allowedPattern": "^arn:(aws[a-zA-Z-]*)?:iam::\\\\d{12}:role/[\\\\w+=,.@-]+",
              "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
              "type": "String",
            },
            "BlockPublicAcls": Object {
              "default": true,
              "description": "(Optional) Specifies whether Amazon S3 should block public access control lists (ACLs) for buckets in this account.",
              "type": "Boolean",
            },
            "BlockPublicPolicy": Object {
              "default": true,
              "description": "(Optional) Specifies whether Amazon S3 should block public bucket policies for buckets in this account. Setting this element to TRUE causes Amazon S3 to reject calls to PUT Bucket policy if the specified bucket policy allows public access.",
              "type": "Boolean",
            },
            "IgnorePublicAcls": Object {
              "default": true,
              "description": "(Optional) Specifies whether Amazon S3 should ignore public ACLs for buckets in this account. Setting this element to TRUE causes Amazon S3 to ignore all public ACLs on buckets in this account and any objects that they contain.",
              "type": "Boolean",
            },
            "RestrictPublicBuckets": Object {
              "default": true,
              "description": "(Optional) Specifies whether Amazon S3 should restrict public bucket policies for buckets in this account. Setting this element to TRUE restricts access to buckets with public policies to only AWS services and authorized users within this account.",
              "type": "Boolean",
            },
          },
          "schemaVersion": "0.3",
        },
        "DocumentType": "Automation",
        "Name": "SHARR-ConfigureS3PublicAccessBlock",
      },
      "Type": "AWS::SSM::Document",
    },
    "SHARRCreateAccessLoggingBucketAutomationDocument63C3DE52": Object {
      "Properties": Object {
        "Content": Object {
          "assumeRole": "{{ AutomationAssumeRole }}",
          "description": "### Document Name - SHARR-CreateAccessLoggingBucket

## What does this document do?
Creates an S3 bucket for access logging.

## Input Parameters
* AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.
* BucketName: (Required) Name of the bucket to create
",
          "mainSteps": Array [
            Object {
              "action": "aws:executeScript",
              "inputs": Object {
                "Handler": "create_logging_bucket",
                "InputPayload": Object {
                  "AWS_REGION": "{{global:REGION}}",
                  "BucketName": "{{BucketName}}",
                },
                "Runtime": "python3.7",
                "Script": "#!/usr/bin/python
###############################################################################
#  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.    #
#                                                                             #
#  Licensed under the Apache License Version 2.0 (the \\"License\\"). You may not #
#  use this file except in compliance with the License. A copy of the License #
#  is located at                                                              #
#                                                                             #
#      http://www.apache.org/licenses/LICENSE-2.0/                                        #
#                                                                             #
#  or in the \\"license\\" file accompanying this file. This file is distributed  #
#  on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, express #
#  or implied. See the License for the specific language governing permis-    #
#  sions and limitations under the License.                                   #
###############################################################################

import boto3
from botocore.exceptions import ClientError
from botocore.config import Config

def connect_to_s3(boto_config):
    return boto3.client('s3', config=boto_config)

def create_logging_bucket(event, context):
    boto_config = Config(
        retries ={
          'mode': 'standard'
        }
    )
    s3 = connect_to_s3(boto_config)

    try:
        kwargs = {
            'Bucket': event['BucketName'],
            'GrantWrite': 'uri=http://acs.amazonaws.com/groups/s3/LogDelivery',
            'GrantReadACP': 'uri=http://acs.amazonaws.com/groups/s3/LogDelivery'
        }
        if event['AWS_REGION'] != 'us-east-1':
            kwargs['CreateBucketConfiguration'] = {
                'LocationConstraint': event['AWS_REGION']
            }

        s3.create_bucket(**kwargs)

        s3.put_bucket_encryption(
            Bucket=event['BucketName'],
            ServerSideEncryptionConfiguration={
                'Rules': [
                    {
                        'ApplyServerSideEncryptionByDefault': {
                            'SSEAlgorithm': 'AES256'
                        }
                    }
                ]
            }
        )
        return {
            \\"output\\": {
                \\"Message\\": f'Bucket {event[\\"BucketName\\"]} created'
            }
        }
    except ClientError as error:
        if error.response['Error']['Code'] != 'BucketAlreadyExists' and \\\\
            error.response['Error']['Code'] != 'BucketAlreadyOwnedByYou':
            exit(str(error))
        else:
            return {
                \\"output\\": {
                    \\"Message\\": f'Bucket {event[\\"BucketName\\"]} already exists'
                }
            }
    except Exception as e:
        print(e)
        exit(str(e))",
              },
              "isEnd": true,
              "name": "CreateAccessLoggingBucket",
              "outputs": Array [
                Object {
                  "Name": "Output",
                  "Selector": "$.Payload.output",
                  "Type": "StringMap",
                },
              ],
            },
          ],
          "outputs": Array [
            "CreateAccessLoggingBucket.Output",
          ],
          "parameters": Object {
            "AutomationAssumeRole": Object {
              "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\\\d{12}:role/[\\\\w+=,.@-]+",
              "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
              "type": "String",
            },
            "BucketName": Object {
              "allowedPattern": "(?=^.{3,63}$)(?!^(\\\\d+\\\\.)+\\\\d+$)(^(([a-z0-9]|[a-z0-9][a-z0-9\\\\-]*[a-z0-9])\\\\.)*([a-z0-9]|[a-z0-9][a-z0-9\\\\-]*[a-z0-9])$)",
              "description": "(Required) The bucket name (not the ARN).",
              "type": "String",
            },
          },
          "schemaVersion": "0.3",
        },
        "DocumentType": "Automation",
        "Name": "SHARR-CreateAccessLoggingBucket",
      },
      "Type": "AWS::SSM::Document",
    },
    "SHARRCreateCloudTrailMultiRegionTrailAutomationDocument59B9EAA0": Object {
      "Properties": Object {
        "Content": Object {
          "assumeRole": "{{ AutomationAssumeRole }}",
          "description": "### Document Name - SHARR-CreateCloudTrailMultiRegionTrail
## What does this document do?
Creates a multi-region trail with KMS encryption and enables CloudTrail
Note: this remediation will create a NEW trail.

## Input Parameters
* AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.
* KMSKeyArn (from SSM): Arn of the KMS key to be used to encrypt data

## Security Standards / Controls
* AFSBP v1.0.0:   CloudTrail.1
* CIS v1.2.0:     2.1
* PCI:            CloudTrail.2
",
          "mainSteps": Array [
            Object {
              "action": "aws:executeScript",
              "inputs": Object {
                "Handler": "create_logging_bucket",
                "InputPayload": Object {
                  "account": "{{global:ACCOUNT_ID}}",
                  "kms_key_arn": "{{KMSKeyArn}}",
                  "region": "{{global:REGION}}",
                },
                "Runtime": "python3.7",
                "Script": "#!/usr/bin/python
###############################################################################
#  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.    #
#                                                                             #
#  Licensed under the Apache License Version 2.0 (the \\"License\\"). You may not #
#  use this file except in compliance with the License. A copy of the License #
#  is located at                                                              #
#                                                                             #
#      http://www.apache.org/licenses/LICENSE-2.0/                                        #
#                                                                             #
#  or in the \\"license\\" file accompanying this file. This file is distributed  #
#  on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, express #
#  or implied. See the License for the specific language governing permis-    #
#  sions and limitations under the License.                                   #
###############################################################################

import boto3
from botocore.config import Config
from botocore.exceptions import ClientError

ERROR_CREATING_BUCKET = 'Error creating bucket '

def connect_to_s3(boto_config):
    return boto3.client('s3', config=boto_config)

def create_logging_bucket(event, context):

    boto_config = Config(
        retries ={
            'mode': 'standard'
        }
    )
    s3 = connect_to_s3(boto_config)

    kms_key_arn = event['kms_key_arn']
    aws_account = event['account']
    aws_region = event['region']
    bucket_name = 'so0111-access-logs-' + aws_region + '-' + aws_account

    if create_bucket(s3, bucket_name, aws_region) == 'bucket_exists':
        return {\\"logging_bucket\\": bucket_name}
    encrypt_bucket(s3, bucket_name, kms_key_arn)
    put_access_block(s3, bucket_name)
    put_bucket_acl(s3, bucket_name)

    return {\\"logging_bucket\\": bucket_name}

def create_bucket(s3, bucket_name, aws_region):
    try:
        kwargs = {
            'Bucket': bucket_name,
            'ACL': 'private'
        }
        if aws_region != 'us-east-1':
            kwargs['CreateBucketConfiguration'] = {
                'LocationConstraint': aws_region
            }

        s3.create_bucket(**kwargs)

    except ClientError as ex:
        exception_type = ex.response['Error']['Code']
        # bucket already exists - return
        if exception_type in [\\"BucketAlreadyExists\\", \\"BucketAlreadyOwnedByYou\\"]:
            print('Bucket ' + bucket_name + ' already exists')
            return 'bucket_exists'
        else:
            print(ex)
            exit(ERROR_CREATING_BUCKET + bucket_name)
    except Exception as e:
        print(e)
        exit(ERROR_CREATING_BUCKET + bucket_name)

def encrypt_bucket(s3, bucket_name, kms_key_arn):
    try:
        s3.put_bucket_encryption(
            Bucket=bucket_name,
            ServerSideEncryptionConfiguration={
                'Rules': [
                    {
                        'ApplyServerSideEncryptionByDefault': {
                            'SSEAlgorithm': 'aws:kms',
                            'KMSMasterKeyID': kms_key_arn.split('key/')[1]
                        }
                    }
                ]
            }
        )
    except Exception as e:
        exit('Error encrypting bucket ' + bucket_name + ': ' + str(e))

def put_access_block(s3, bucket_name):
    try:
        s3.put_public_access_block(
            Bucket=bucket_name,
            PublicAccessBlockConfiguration={
                'BlockPublicAcls': True,
                'IgnorePublicAcls': True,
                'BlockPublicPolicy': True,
                'RestrictPublicBuckets': True
            }
        )
    except Exception as e:
        exit('Error setting public access block for bucket ' + bucket_name + ': ' + str(e))

def put_bucket_acl(s3, bucket_name):
    try:
        s3.put_bucket_acl(
            Bucket=bucket_name,
            GrantReadACP='uri=http://acs.amazonaws.com/groups/s3/LogDelivery',
            GrantWrite='uri=http://acs.amazonaws.com/groups/s3/LogDelivery'
        )
    except Exception as e:
        exit('Error setting ACL for bucket ' + bucket_name + ': ' + str(e))",
              },
              "isEnd": false,
              "name": "CreateLoggingBucket",
              "outputs": Array [
                Object {
                  "Name": "LoggingBucketName",
                  "Selector": "$.Payload.logging_bucket",
                  "Type": "String",
                },
              ],
            },
            Object {
              "action": "aws:executeScript",
              "inputs": Object {
                "Handler": "create_encrypted_bucket",
                "InputPayload": Object {
                  "account": "{{global:ACCOUNT_ID}}",
                  "kms_key_arn": "{{KMSKeyArn}}",
                  "logging_bucket": "{{CreateLoggingBucket.LoggingBucketName}}",
                  "region": "{{global:REGION}}",
                },
                "Runtime": "python3.7",
                "Script": "#!/usr/bin/python
###############################################################################
#  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.    #
#                                                                             #
#  Licensed under the Apache License Version 2.0 (the \\"License\\"). You may not #
#  use this file except in compliance with the License. A copy of the License #
#  is located at                                                              #
#                                                                             #
#      http://www.apache.org/licenses/LICENSE-2.0                                     #
#                                                                             #
#  or in the \\"license\\" file accompanying this file. This file is distributed  #
#  on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, express #
#  or implied. See the License for the specific language governing permis-    #
#  sions and limitations under the License.                                   #
###############################################################################

import boto3
from botocore.config import Config
from botocore.exceptions import ClientError

def connect_to_s3(boto_config):
    return boto3.client('s3', config=boto_config)

def create_encrypted_bucket(event, context):

    boto_config = Config(
        retries ={
          'mode': 'standard'
        }
    )
    s3 = connect_to_s3(boto_config)

    kms_key_arn = event['kms_key_arn']
    aws_account = event['account']
    aws_region = event['region']
    logging_bucket = event['logging_bucket']
    bucket_name = 'so0111-aws-cloudtrail-' + aws_account

    if create_s3_bucket(s3, bucket_name, aws_region) == 'bucket_exists':
        return {\\"cloudtrail_bucket\\": bucket_name}
    put_bucket_encryption(s3, bucket_name, kms_key_arn)
    put_public_access_block(s3, bucket_name)
    put_bucket_logging(s3, bucket_name, logging_bucket)

    return {\\"cloudtrail_bucket\\": bucket_name}

def create_s3_bucket(s3, bucket_name, aws_region):
    try:
        kwargs = {
            'Bucket': bucket_name,
            'ACL': 'private'
        }
        if aws_region != 'us-east-1':
            kwargs['CreateBucketConfiguration'] = {
                'LocationConstraint': aws_region
            }

        s3.create_bucket(**kwargs)

    except ClientError as client_ex:
        exception_type = client_ex.response['Error']['Code']
        if exception_type in [\\"BucketAlreadyExists\\", \\"BucketAlreadyOwnedByYou\\"]:
          print('Bucket ' + bucket_name + ' already exists')
          return 'bucket_exists'
        else:
            exit('Error creating bucket ' + bucket_name + ' ' + str(client_ex))
    except Exception as e:
        exit('Error creating bucket ' + bucket_name + ' ' + str(e))

def put_bucket_encryption(s3, bucket_name, kms_key_arn):
    try:
        s3.put_bucket_encryption(
            Bucket=bucket_name,
            ServerSideEncryptionConfiguration={
                'Rules': [
                    {
                        'ApplyServerSideEncryptionByDefault': {
                            'SSEAlgorithm': 'aws:kms',
                            'KMSMasterKeyID': kms_key_arn.split('key/')[1]
                        }
                    }
                ]
            }
        )
    except Exception as e:
        print(e)
        exit('Error applying encryption to bucket ' + bucket_name + ' with key ' + kms_key_arn)

def put_public_access_block(s3, bucket_name):
    try:
        s3.put_public_access_block(
            Bucket=bucket_name,
            PublicAccessBlockConfiguration={
                'BlockPublicAcls': True,
                'IgnorePublicAcls': True,
                'BlockPublicPolicy': True,
                'RestrictPublicBuckets': True
            }
        )
    except Exception as e:
        exit(f'Error setting public access block for bucket {bucket_name}: {str(e)}')

def put_bucket_logging(s3, bucket_name, logging_bucket):
    try:
        s3.put_bucket_logging(
            Bucket=bucket_name,
            BucketLoggingStatus={
                'LoggingEnabled': {
                    'TargetBucket': logging_bucket,
                    'TargetPrefix': 'cloudtrail-access-logs'
                }
            }
        )
    except Exception as e:
        print(e)
        exit('Error setting public access block for bucket ' + bucket_name)",
              },
              "isEnd": false,
              "name": "CreateCloudTrailBucket",
              "outputs": Array [
                Object {
                  "Name": "CloudTrailBucketName",
                  "Selector": "$.Payload.cloudtrail_bucket",
                  "Type": "String",
                },
              ],
            },
            Object {
              "action": "aws:executeScript",
              "inputs": Object {
                "Handler": "create_bucket_policy",
                "InputPayload": Object {
                  "account": "{{global:ACCOUNT_ID}}",
                  "cloudtrail_bucket": "{{CreateCloudTrailBucket.CloudTrailBucketName}}",
                  "partition": "{{AWSPartition}}",
                },
                "Runtime": "python3.7",
                "Script": "#!/usr/bin/python
###############################################################################
#  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.    #
#                                                                             #
#  Licensed under the Apache License Version 2.0 (the \\"License\\"). You may not #
#  use this file except in compliance with the License. A copy of the License #
#  is located at                                                              #
#                                                                             #
#      http://www.apache.org/licenses/LICENSE-2.0/                                        #
#                                                                             #
#  or in the \\"license\\" file accompanying this file. This file is distributed  #
#  on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, express #
#  or implied. See the License for the specific language governing permis-    #
#  sions and limitations under the License.                                   #
###############################################################################

import json
import boto3
from botocore.config import Config
from botocore.exceptions import ClientError

def connect_to_s3(boto_config):
    return boto3.client('s3', config=boto_config)

def create_bucket_policy(event, context):

    boto_config = Config(
        retries ={
          'mode': 'standard'
        }
    )
    s3 = connect_to_s3(boto_config)

    cloudtrail_bucket = event['cloudtrail_bucket']
    aws_partition = event['partition']
    aws_account = event['account']
    try:
        bucket_policy = {
            \\"Version\\": \\"2012-10-17\\",
            \\"Statement\\": [
                {
                    \\"Sid\\": \\"AWSCloudTrailAclCheck20150319\\",
                    \\"Effect\\": \\"Allow\\",
                    \\"Principal\\": {
                        \\"Service\\": [
                            \\"cloudtrail.amazonaws.com\\"
                        ]
                    },
                    \\"Action\\": \\"s3:GetBucketAcl\\",
                    \\"Resource\\": \\"arn:\\" + aws_partition + \\":s3:::\\" + cloudtrail_bucket
                },
                {
                    \\"Sid\\": \\"AWSCloudTrailWrite20150319\\",
                    \\"Effect\\": \\"Allow\\",
                    \\"Principal\\": {
                        \\"Service\\": [
                            \\"cloudtrail.amazonaws.com\\"
                        ]
                    },
                    \\"Action\\": \\"s3:PutObject\\",
                    \\"Resource\\": \\"arn:\\" + aws_partition + \\":s3:::\\" + cloudtrail_bucket + \\"/AWSLogs/\\" + aws_account + \\"/*\\",
                    \\"Condition\\": { 
                        \\"StringEquals\\": { 
                            \\"s3:x-amz-acl\\": \\"bucket-owner-full-control\\"
                        }
                    }
                }
            ]
        }
        s3.put_bucket_policy(
            Bucket=cloudtrail_bucket,
            Policy=json.dumps(bucket_policy)
        )
        return {
            \\"output\\": {
                \\"Message\\": f'Set bucket policy for bucket {cloudtrail_bucket}'
            }
        }
    except Exception as e:
        print(e)
        exit('PutBucketPolicy failed: ' + str(e))",
              },
              "isEnd": false,
              "name": "CreateCloudTrailBucketPolicy",
            },
            Object {
              "action": "aws:executeScript",
              "inputs": Object {
                "Handler": "enable_cloudtrail",
                "InputPayload": Object {
                  "cloudtrail_bucket": "{{CreateCloudTrailBucket.CloudTrailBucketName}}",
                  "kms_key_arn": "{{KMSKeyArn}}",
                },
                "Runtime": "python3.7",
                "Script": "#!/usr/bin/python
###############################################################################
#  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.    #
#                                                                             #
#  Licensed under the Apache License Version 2.0 (the \\"License\\"). You may not #
#  use this file except in compliance with the License. A copy of the License #
#  is located at                                                              #
#                                                                             #
#      http://www.apache.org/licenses/LICENSE-2.0/                                        #
#                                                                             #
#  or in the \\"license\\" file accompanying this file. This file is distributed  #
#  on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, express #
#  or implied. See the License for the specific language governing permis-    #
#  sions and limitations under the License.                                   #
###############################################################################

import boto3
from botocore.config import Config
from botocore.exceptions import ClientError

def connect_to_cloudtrail(boto_config):
    return boto3.client('cloudtrail', config=boto_config)

def enable_cloudtrail(event, context):

    boto_config = Config(
        retries ={
          'mode': 'standard'
        }
    )
    ct = connect_to_cloudtrail(boto_config)

    try:
        ct.create_trail(
            Name='multi-region-cloud-trail',
            S3BucketName=event['cloudtrail_bucket'],
            IncludeGlobalServiceEvents=True,
            EnableLogFileValidation=True,
            IsMultiRegionTrail=True,
            KmsKeyId=event['kms_key_arn']
        )
        ct.start_logging(
            Name='multi-region-cloud-trail'
        )
        return {
            \\"output\\": {
                \\"Message\\": f'CloudTrail Trail multi-region-cloud-trail created'
            }
        }
    except Exception as e:
        exit('Error enabling AWS Config: ' + str(e))
        ",
              },
              "isEnd": false,
              "name": "EnableCloudTrail",
              "outputs": Array [
                Object {
                  "Name": "CloudTrailBucketName",
                  "Selector": "$.Payload.cloudtrail_bucket",
                  "Type": "String",
                },
              ],
            },
            Object {
              "action": "aws:executeScript",
              "inputs": Object {
                "Handler": "process_results",
                "InputPayload": Object {
                  "cloudtrail_bucket": "{{CreateCloudTrailBucket.CloudTrailBucketName}}",
                  "logging_bucket": "{{CreateLoggingBucket.LoggingBucketName}}",
                },
                "Runtime": "python3.7",
                "Script": "#!/usr/bin/python
###############################################################################
#  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.    #
#                                                                             #
#  Licensed under the Apache License Version 2.0 (the \\"License\\"). You may not #
#  use this file except in compliance with the License. A copy of the License #
#  is located at                                                              #
#                                                                             #
#      http://www.apache.org/licenses/LICENSE-2.0/                                        #
#                                                                             #
#  or in the \\"license\\" file accompanying this file. This file is distributed  #
#  on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, express #
#  or implied. See the License for the specific language governing permis-    #
#  sions and limitations under the License.                                   #
###############################################################################

def process_results(event, context):
  print(f'Created encrypted CloudTrail bucket {event[\\"cloudtrail_bucket\\"]}')
  print(f'Created access logging for CloudTrail bucket in bucket {event[\\"logging_bucket\\"]}')
  print('Enabled multi-region AWS CloudTrail')
  return {
    \\"response\\": {
      \\"message\\": \\"AWS CloudTrail successfully enabled\\",
      \\"status\\": \\"Success\\"
    }
  }",
              },
              "isEnd": true,
              "name": "Remediation",
              "outputs": Array [
                Object {
                  "Name": "Output",
                  "Selector": "$",
                  "Type": "StringMap",
                },
              ],
            },
          ],
          "outputs": Array [
            "Remediation.Output",
          ],
          "parameters": Object {
            "AWSPartition": Object {
              "allowedValues": Array [
                "aws",
                "aws-cn",
                "aws-us-gov",
              ],
              "default": "aws",
              "description": "Partition for creation of ARNs.",
              "type": "String",
            },
            "AutomationAssumeRole": Object {
              "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\\\d{12}:role/[\\\\w+=,.@-]+",
              "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
              "type": "String",
            },
            "KMSKeyArn": Object {
              "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):kms:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\\\d):\\\\d{12}:(?:(?:alias/[A-Za-z0-9/-_])|(?:key/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})))$",
              "default": "{{ssm:/Solutions/SO0111/CMK_REMEDIATION_ARN}}",
              "description": "The ARN of the KMS key created by SHARR for this remediation",
              "type": "String",
            },
          },
          "schemaVersion": "0.3",
        },
        "DocumentType": "Automation",
        "Name": "SHARR-CreateCloudTrailMultiRegionTrail",
      },
      "Type": "AWS::SSM::Document",
    },
    "SHARRCreateLogMetricFilterAndAlarmAutomationDocument0AE52F3F": Object {
      "Properties": Object {
        "Content": Object {
          "assumeRole": "{{ AutomationAssumeRole }}",
          "description": "### Document Name - SHARR-CreateLogMetricFilterAndAlarm
## What does this document do?
Creates a metric filter for a given log group and also creates and alarm for the metric.

## Input Parameters
* AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.
* CloudWatch Log Group Name: Name of the CloudWatch log group to use to create metric filter
* Alarm Value: Threshhold value for the creating an alarm for the CloudWatch Alarm

## Security Standards / Controls
* CIS v1.2.0:     3.1-3.14
",
          "mainSteps": Array [
            Object {
              "action": "aws:executeScript",
              "inputs": Object {
                "Handler": "create_encrypted_topic",
                "InputPayload": Object {
                  "kms_key_arn": "{{KMSKeyArn}}",
                  "topic_name": "{{SNSTopicName}}",
                },
                "Runtime": "python3.7",
                "Script": "#!/usr/bin/python
###############################################################################
#  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.         #
#                                                                             #
#  Licensed under the Apache License Version 2.0 (the \\"License\\"). You may not #
#  use this file except in compliance with the License. A copy of the License #
#  is located at                                                              #
#                                                                             #
#      http://www.apache.org/licenses/LICENSE-2.0                             #
#                                                                             #
#  or in the \\"license\\" file accompanying this file. This file is distributed  #
#  on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, express #
#  or implied. See the License for the specific language governing permis-    # 
#  sions and limitations under the License.                                   #
###############################################################################

import json
import boto3
from botocore.config import Config
from botocore.exceptions import ClientError

boto_config = Config(
    retries ={
        'mode': 'standard'
    }
)

def connect_to_sns():
    return boto3.client('sns', config=boto_config)

def connect_to_ssm():
    return boto3.client('ssm', config=boto_config)

def create_encrypted_topic(event, context):

    kms_key_arn = event['kms_key_arn']
    new_topic = False
    topic_arn = ''
    topic_name = event['topic_name']

    try:
        sns = connect_to_sns()
        topic_arn = sns.create_topic(
            Name=topic_name,
            Attributes={
                'KmsMasterKeyId': kms_key_arn.split('key/')[1]
            }
        )['TopicArn']
        new_topic = True

    except ClientError as client_exception:
        exception_type = client_exception.response['Error']['Code']
        if exception_type == 'InvalidParameter':
            print(f'Topic {topic_name} already exists. This remediation may have been run before.')
            print('Ignoring exception - remediation continues.')
            topic_arn = sns.create_topic(
                Name=topic_name
            )['TopicArn']
        else:
            exit(f'ERROR: Unhandled client exception: {client_exception}')
      
    except Exception as e:
        exit(f'ERROR: could not create SNS Topic {topic_name}: {str(e)}')

    if new_topic:
        try:
            ssm = connect_to_ssm()
            ssm.put_parameter(
                Name='/Solutions/SO0111/SNS_Topic_CIS3.x',
                Description='SNS Topic for AWS Config updates',
                Type='String',
                Overwrite=True,
                Value=topic_arn
            )               
        except Exception as e:
            exit(f'ERROR: could not create SNS Topic {topic_name}: {str(e)}')

    create_topic_policy(topic_arn)
    
    return {\\"topic_arn\\": topic_arn} 

def create_topic_policy(topic_arn):
    sns = connect_to_sns()
    try:
        topic_policy = {
            \\"Id\\": \\"Policy_ID\\",
            \\"Statement\\": [
            {
                \\"Sid\\": \\"AWSConfigSNSPolicy\\",
                \\"Effect\\": \\"Allow\\",
                \\"Principal\\": {
                \\"Service\\": \\"cloudwatch.amazonaws.com\\"
                },
                \\"Action\\": \\"SNS:Publish\\",
                \\"Resource\\": topic_arn,
            }]
        }
            
        sns.set_topic_attributes(
            TopicArn=topic_arn,
            AttributeName='Policy',
            AttributeValue=json.dumps(topic_policy)
        )
    except Exception as e:
        exit(f'ERROR: Failed to SetTopicAttributes for {topic_arn}: {str(e)}')",
              },
              "name": "CreateTopic",
              "outputs": Array [
                Object {
                  "Name": "TopicArn",
                  "Selector": "$.Payload.topic_arn",
                  "Type": "String",
                },
              ],
            },
            Object {
              "action": "aws:executeScript",
              "inputs": Object {
                "Handler": "verify",
                "InputPayload": Object {
                  "AlarmDesc": "{{AlarmDesc}}",
                  "AlarmName": "{{AlarmName}}",
                  "AlarmThreshold": "{{AlarmThreshold}}",
                  "FilterName": "{{FilterName}}",
                  "FilterPattern": "{{FilterPattern}}",
                  "LogGroupName": "{{LogGroupName}}",
                  "MetricName": "{{MetricName}}",
                  "MetricNamespace": "{{MetricNamespace}}",
                  "MetricValue": "{{MetricValue}}",
                  "TopicArn": "{{CreateTopic.TopicArn}}",
                },
                "Runtime": "python3.7",
                "Script": "#!/usr/bin/python
###############################################################################
#  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.         #
#                                                                             #
#  Licensed under the Apache License Version 2.0 (the \\"License\\"). You may not #
#  use this file except in compliance with the License. A copy of the License #
#  is located at                                                              #
#                                                                             #
#      http://www.apache.org/licenses/LICENSE-2.0/                            #
#                                                                             #
#  or in the \\"license\\" file accompanying this file. This file is distributed  #
#  on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, express #
#  or implied. See the License for the specific language governing permis-    #
#  sions and limitations under the License.                                   #
###############################################################################

import boto3
import logging
import os
from botocore.config import Config

boto_config = Config(
    retries={
        'max_attempts': 10,
        'mode': 'standard'
    }
)

log = logging.getLogger()
LOG_LEVEL = str(os.getenv('LogLevel', 'INFO'))
log.setLevel(LOG_LEVEL)


def get_service_client(service_name):
    \\"\\"\\"
    Returns the service client for given the service name
    :param service_name: name of the service
    :return: service client
    \\"\\"\\"
    log.debug(\\"Getting the service client for service: {}\\".format(service_name))
    return boto3.client(service_name, config=boto_config)


def put_metric_filter(cw_log_group, filter_name, filter_pattern, metric_name, metric_namespace, metric_value):
    \\"\\"\\"
    Puts the metric filter on the CloudWatch log group with provided values
    :param cw_log_group: Name of the CloudWatch log group
    :param filter_name: Name of the filter
    :param filter_pattern: Pattern for the filter
    :param metric_name: Name of the metric
    :param metric_namespace: Namespace where metric is logged
    :param metric_value: Value to be logged for the metric
    \\"\\"\\"
    logs_client = get_service_client('logs')
    log.debug(\\"Putting the metric filter with values: {}\\".format([
        cw_log_group, filter_name, filter_pattern, metric_name, metric_namespace, metric_value]))
    try:
        logs_client.put_metric_filter(
            logGroupName=cw_log_group,
            filterName=filter_name,
            filterPattern=filter_pattern,
            metricTransformations=[
                {
                    'metricName': metric_name,
                    'metricNamespace': metric_namespace,
                    'metricValue': str(metric_value),
                    'unit': 'Count'
                }
            ]
        )
    except Exception as e:
        exit(\\"Exception occurred while putting metric filter: \\" + str(e))
    log.debug(\\"Successfully added the metric filter.\\")


def put_metric_alarm(alarm_name, alarm_desc, alarm_threshold, metric_name, metric_namespace, topic_arn):
    \\"\\"\\"
    Puts the metric alarm for the metric name with provided values
    :param alarm_name: Name for the alarm
    :param alarm_desc: Description for the alarm
    :param alarm_threshold: Threshold value for the alarm
    :param metric_name: Name of the metric
    :param metric_namespace: Namespace where metric is logged
    \\"\\"\\"
    cw_client = get_service_client('cloudwatch')
    log.debug(\\"Putting the metric alarm with values {}\\".format(
        [alarm_name, alarm_desc, alarm_threshold, metric_name, metric_namespace]))
    try:
        cw_client.put_metric_alarm(
            AlarmName=alarm_name,
            AlarmDescription=alarm_desc,
            ActionsEnabled=True,
            OKActions=[
                topic_arn
            ],
            AlarmActions=[
                topic_arn
            ],
            MetricName=metric_name,
            Namespace=metric_namespace,
            Statistic='Sum',
            Period=300,
            Unit='Count',
            EvaluationPeriods=12,
            DatapointsToAlarm=1,
            Threshold=alarm_threshold,
            ComparisonOperator='GreaterThanOrEqualToThreshold',
            TreatMissingData='notBreaching'
        )
    except Exception as e:
        exit(\\"Exception occurred while putting metric alarm: \\" + str(e))
    log.debug(\\"Successfully added metric alarm.\\")


def verify(event, context):
    log.info(\\"Begin handler\\")
    log.debug(\\"====Print Event====\\")
    log.debug(event)

    filter_name = event['FilterName']
    filter_pattern = event['FilterPattern']
    metric_name = event['MetricName']
    metric_namespace = event['MetricNamespace']
    metric_value = event['MetricValue']
    alarm_name = event['AlarmName']
    alarm_desc = event['AlarmDesc']
    alarm_threshold = event['AlarmThreshold']
    cw_log_group = event['LogGroupName']
    topic_arn = event['TopicArn']

    put_metric_filter(cw_log_group, filter_name, filter_pattern, metric_name, metric_namespace, metric_value)
    put_metric_alarm(alarm_name, alarm_desc, alarm_threshold, metric_name, metric_namespace, topic_arn)
    return {
        \\"response\\": {
            \\"message\\": f'Created filter {event[\\"FilterName\\"]} for metric {event[\\"MetricName\\"]}, and alarm {event[\\"AlarmName\\"]}',
            \\"status\\": \\"Success\\"
        }
    }",
              },
              "name": "CreateMetricFilerAndAlarm",
              "outputs": Array [
                Object {
                  "Name": "Output",
                  "Selector": "$.Payload.response",
                  "Type": "StringMap",
                },
              ],
            },
          ],
          "parameters": Object {
            "AlarmDesc": Object {
              "description": "Description of the Alarm to be created for the metric filter",
              "type": "String",
            },
            "AlarmName": Object {
              "description": "Name of the Alarm to be created for the metric filter",
              "type": "String",
            },
            "AlarmThreshold": Object {
              "description": "Threshold value for the alarm",
              "type": "Integer",
            },
            "AutomationAssumeRole": Object {
              "allowedPattern": "^arn:(aws[a-zA-Z-]*)?:iam::\\\\d{12}:role/[\\\\w+=,.@/-]+$",
              "description": "(Required) The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that allows Systems Manager Automation to perform the actions on your behalf.",
              "type": "String",
            },
            "FilterName": Object {
              "description": "Name for the metric filter",
              "type": "String",
            },
            "FilterPattern": Object {
              "description": "Filter pattern to create metric filter",
              "type": "String",
            },
            "KMSKeyArn": Object {
              "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):kms:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\\\d):\\\\d{12}:(?:(?:alias/[A-Za-z0-9/-_])|(?:key/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})))$",
              "description": "The ARN of a KMS key to use for encryption of the SNS Topic and Config bucket",
              "type": "String",
            },
            "LogGroupName": Object {
              "description": "Name of the log group to be used to create metric filter",
              "type": "String",
            },
            "MetricName": Object {
              "description": "Name of the metric for metric filter",
              "type": "String",
            },
            "MetricNamespace": Object {
              "description": "Namespace where the metrics will be sent",
              "type": "String",
            },
            "MetricValue": Object {
              "description": "Value of the metric for metric filter",
              "type": "Integer",
            },
            "SNSTopicName": Object {
              "allowedPattern": "^[a-zA-Z0-9][a-zA-Z0-9-_]{0,255}$",
              "type": "String",
            },
          },
          "schemaVersion": "0.3",
        },
        "DocumentType": "Automation",
        "Name": "SHARR-CreateLogMetricFilterAndAlarm",
      },
      "Type": "AWS::SSM::Document",
    },
    "SHARREnableAWSConfigAutomationDocument5BFC17F4": Object {
      "Properties": Object {
        "Content": Object {
          "assumeRole": "{{ AutomationAssumeRole }}",
          "description": "### Document name - SHARR-EnableAWSConfig

## What does this document do?
Enables AWS Config:
* Turns on recording for all resources.
* Creates an encrypted bucket for Config logging.
* Creates a logging bucket for access logs for the config bucket
* Creates an SNS topic for Config notifications
* Creates a service-linked role

## Input Parameters
* AutomationAssumeRole: (Required) The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that allows Systems Manager Automation to perform the actions on your behalf.
* KMSKeyArn: KMS Customer-managed key to use for encryption of Config log data and SNS Topic
* AWSServiceRoleForConfig: (Optional) The name of the exiting IAM role to use for the Config service. Default: aws-service-role/config.amazonaws.com/AWSServiceRoleForConfig
* SNSTopicName: (Required) Name of the SNS Topic to use to post AWS Config messages.

## Output Parameters
* Remediation.Output: STDOUT and messages from the remediation steps.
",
          "mainSteps": Array [
            Object {
              "action": "aws:executeScript",
              "inputs": Object {
                "Handler": "create_encrypted_topic",
                "InputPayload": Object {
                  "kms_key_arn": "{{KMSKeyArn}}",
                  "topic_name": "{{SNSTopicName}}",
                },
                "Runtime": "python3.7",
                "Script": "#!/usr/bin/python
###############################################################################
#  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.         #
#                                                                             #
#  Licensed under the Apache License Version 2.0 (the \\"License\\"). You may not #
#  use this file except in compliance with the License. A copy of the License #
#  is located at                                                              #
#                                                                             #
#      http://www.apache.org/licenses/LICENSE-2.0                             #
#                                                                             #
#  or in the \\"license\\" file accompanying this file. This file is distributed  #
#  on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, express #
#  or implied. See the License for the specific language governing permis-    # 
#  sions and limitations under the License.                                   #
###############################################################################

import json
import boto3
from botocore.config import Config
from botocore.exceptions import ClientError

boto_config = Config(
    retries ={
        'mode': 'standard'
    }
)

def connect_to_sns():
    return boto3.client('sns', config=boto_config)

def connect_to_ssm():
    return boto3.client('ssm', config=boto_config)

def create_encrypted_topic(event, context):

    kms_key_arn = event['kms_key_arn']
    new_topic = False
    topic_arn = ''
    topic_name = event['topic_name']

    try:
        sns = connect_to_sns()
        topic_arn = sns.create_topic(
            Name=topic_name,
            Attributes={
                'KmsMasterKeyId': kms_key_arn.split('key/')[1]
            }
        )['TopicArn']
        new_topic = True

    except ClientError as client_exception:
        exception_type = client_exception.response['Error']['Code']
        if exception_type == 'InvalidParameter':
            print(f'Topic {topic_name} already exists. This remediation may have been run before.')
            print('Ignoring exception - remediation continues.')
            topic_arn = sns.create_topic(
                Name=topic_name
            )['TopicArn']
        else:
            exit(f'ERROR: Unhandled client exception: {client_exception}')
      
    except Exception as e:
        exit(f'ERROR: could not create SNS Topic {topic_name}: {str(e)}')

    if new_topic:
        try:
            ssm = connect_to_ssm()
            ssm.put_parameter(
                Name='/Solutions/SO0111/SNS_Topic_Config.1',
                Description='SNS Topic for AWS Config updates',
                Type='String',
                Overwrite=True,
                Value=topic_arn
            )               
        except Exception as e:
            exit(f'ERROR: could not create SNS Topic {topic_name}: {str(e)}')

    create_topic_policy(topic_arn)
    
    return {\\"topic_arn\\": topic_arn} 

def create_topic_policy(topic_arn):
    sns = connect_to_sns()
    try:
        topic_policy = {
            \\"Id\\": \\"Policy_ID\\",
            \\"Statement\\": [
            {
                \\"Sid\\": \\"AWSConfigSNSPolicy\\",
                \\"Effect\\": \\"Allow\\",
                \\"Principal\\": {
                \\"Service\\": \\"config.amazonaws.com\\"
                },
                \\"Action\\": \\"SNS:Publish\\",
                \\"Resource\\": topic_arn,
            }]
        }
            
        sns.set_topic_attributes(
            TopicArn=topic_arn,
            AttributeName='Policy',
            AttributeValue=json.dumps(topic_policy)
        )
    except Exception as e:
        exit(f'ERROR: Failed to SetTopicAttributes for {topic_arn}: {str(e)}')",
              },
              "isEnd": false,
              "name": "CreateTopic",
              "outputs": Array [
                Object {
                  "Name": "TopicArn",
                  "Selector": "$.Payload.topic_arn",
                  "Type": "String",
                },
              ],
            },
            Object {
              "action": "aws:executeAutomation",
              "inputs": Object {
                "DocumentName": "SHARR-CreateAccessLoggingBucket",
                "RuntimeParameters": Object {
                  "AutomationAssumeRole": "arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/SO0111-CreateAccessLoggingBucket",
                  "BucketName": "so0111-accesslogs-{{global:ACCOUNT_ID}}-{{global:REGION}}",
                },
              },
              "isEnd": false,
              "name": "CreateAccessLoggingBucket",
            },
            Object {
              "action": "aws:executeScript",
              "inputs": Object {
                "Handler": "create_encrypted_bucket",
                "InputPayload": Object {
                  "account": "{{global:ACCOUNT_ID}}",
                  "kms_key_arn": "{{KMSKeyArn}}",
                  "logging_bucket": "so0111-accesslogs-{{global:ACCOUNT_ID}}-{{global:REGION}}",
                  "partition": "{{global:AWS_PARTITION}}",
                  "region": "{{global:REGION}}",
                },
                "Runtime": "python3.7",
                "Script": "#!/usr/bin/python
###############################################################################
#  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.         #
#                                                                             #
#  Licensed under the Apache License Version 2.0 (the \\"License\\"). You may not #
#  use this file except in compliance with the License. A copy of the License #
#  is located at                                                              #
#                                                                             #
#      http://www.apache.org/licenses/LICENSE-2.0/                            #
#                                                                             #
#  or in the \\"license\\" file accompanying this file. This file is distributed  #
#  on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, express #
#  or implied. See the License for the specific language governing permis-    #
#  sions and limitations under the License.                                   #
###############################################################################

import json
import boto3
from botocore.config import Config
from botocore.exceptions import ClientError
from botocore.retries import bucket

boto_config = Config(
    retries ={
        'mode': 'standard'
    }
)

def connect_to_s3(boto_config):
    return boto3.client('s3', config=boto_config)

def create_bucket(bucket_name, aws_region):
    s3 = connect_to_s3(boto_config)
    try:
        if aws_region == 'us-east-1':
            s3.create_bucket(
                ACL='private',
                Bucket=bucket_name
            )
        else:
            s3.create_bucket(
                ACL='private',
                Bucket=bucket_name,
                CreateBucketConfiguration={
                    'LocationConstraint': aws_region
                }
            )
        return \\"created\\"

    except ClientError as ex:
        exception_type = ex.response['Error']['Code']
        # bucket already exists - return
        if exception_type in [\\"BucketAlreadyExists\\", \\"BucketAlreadyOwnedByYou\\"]:
            print('Bucket ' + bucket_name + ' already exists')
            return \\"already exists\\"
        else:
            exit(f'ERROR creating bucket {bucket_name}: {str(ex)}')
    except Exception as e:
        exit(f'ERROR creating bucket {bucket_name}: {str(e)}')

def encrypt_bucket(bucket_name, kms_key):
    s3 = connect_to_s3(boto_config)
    try:
        s3.put_bucket_encryption(
        Bucket=bucket_name,
        ServerSideEncryptionConfiguration={
        'Rules': [
            {
            'ApplyServerSideEncryptionByDefault': {
                'SSEAlgorithm': 'aws:kms',
                'KMSMasterKeyID': kms_key
            }
            }
        ]
        }
    )
    except Exception as e:
        exit(f'ERROR putting bucket encryption for {bucket_name}: {str(e)}')

def block_public_access(bucket_name):
    s3 = connect_to_s3(boto_config)
    try:
        s3.put_public_access_block(
            Bucket=bucket_name,
            PublicAccessBlockConfiguration={
                'BlockPublicAcls': True,
                'IgnorePublicAcls': True,
                'BlockPublicPolicy': True,
                'RestrictPublicBuckets': True
            }
        )
    except Exception as e:
        exit(f'ERROR setting public access block for bucket {bucket_name}: {str(e)}')

def enable_access_logging(bucket_name, logging_bucket):
    s3 = connect_to_s3(boto_config)
    try:
        s3.put_bucket_logging(
            Bucket=bucket_name,
            BucketLoggingStatus={
            'LoggingEnabled': {
                'TargetBucket': logging_bucket,
                'TargetPrefix': f'access-logs/{bucket_name}'
            }
            }
        )
    except Exception as e:
        exit(f'Error setting access logging for bucket {bucket_name}: {str(e)}')

def create_bucket_policy(config_bucket, aws_partition):  
    s3 = connect_to_s3(boto_config)   
    try:
        bucket_policy = {
            \\"Version\\": \\"2012-10-17\\",
            \\"Statement\\": [
            {
                \\"Sid\\": \\"AWSConfigBucketPermissionsCheck\\",
                \\"Effect\\": \\"Allow\\",
                \\"Principal\\": {
                    \\"Service\\": [
                        \\"config.amazonaws.com\\"
                    ]
                },
                \\"Action\\": \\"s3:GetBucketAcl\\",
                \\"Resource\\": \\"arn:\\" + aws_partition + \\":s3:::\\" + config_bucket
            },
            {
                \\"Sid\\": \\"AWSConfigBucketExistenceCheck\\",
                \\"Effect\\": \\"Allow\\",
                \\"Principal\\": {
                    \\"Service\\": [
                        \\"config.amazonaws.com\\"
                    ]
                },
                \\"Action\\": \\"s3:ListBucket\\",
                \\"Resource\\": \\"arn:\\" + aws_partition + \\":s3:::\\" + config_bucket
            },
            {
                \\"Sid\\": \\"AWSConfigBucketDelivery\\",
                \\"Effect\\": \\"Allow\\",
                \\"Principal\\": {
                    \\"Service\\": [
                        \\"config.amazonaws.com\\"    
                    ]
                },
                \\"Action\\": \\"s3:PutObject\\",
                \\"Resource\\": \\"arn:\\" + aws_partition + \\":s3:::\\" + config_bucket + \\"/*\\",
                \\"Condition\\": { 
                    \\"StringEquals\\": { 
                        \\"s3:x-amz-acl\\": \\"bucket-owner-full-control\\"
                    }
                }
            }
            ]
        }
        s3.put_bucket_policy(
            Bucket=config_bucket,
            Policy=json.dumps(bucket_policy)
        )
    except Exception as e:
        exit(f'ERROR: PutBucketPolicy failed for {config_bucket}: {str(e)}')

def create_encrypted_bucket(event, context):
    
    kms_key_arn = event['kms_key_arn']
    aws_partition = event['partition']
    aws_account = event['account']
    aws_region = event['region']
    logging_bucket = event['logging_bucket']
    bucket_name = 'so0111-aws-config-' + aws_region + '-' + aws_account

    if create_bucket(bucket_name, aws_region) == 'already exists':
        return {\\"config_bucket\\": bucket_name}

    encrypt_bucket(bucket_name, kms_key_arn.split('key/')[1])
    block_public_access(bucket_name)
    enable_access_logging(bucket_name, logging_bucket)
    create_bucket_policy(bucket_name, aws_partition)

    return {\\"config_bucket\\": bucket_name}",
              },
              "isEnd": false,
              "name": "CreateConfigBucket",
              "outputs": Array [
                Object {
                  "Name": "ConfigBucketName",
                  "Selector": "$.Payload.config_bucket",
                  "Type": "String",
                },
              ],
            },
            Object {
              "action": "aws:executeScript",
              "inputs": Object {
                "Handler": "enable_config",
                "InputPayload": Object {
                  "account": "{{global:ACCOUNT_ID}}",
                  "aws_service_role": "{{AWSServiceRoleForConfig}}",
                  "config_bucket": "{{CreateConfigBucket.ConfigBucketName}}",
                  "partition": "{{global:AWS_PARTITION}}",
                  "region": "{{global:REGION}}",
                  "topic_arn": "{{CreateTopic.TopicArn}}",
                },
                "Runtime": "python3.7",
                "Script": "#!/usr/bin/python
###############################################################################
#  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.         #
#                                                                             #
#  Licensed under the Apache License Version 2.0 (the \\"License\\"). You may not #
#  use this file except in compliance with the License. A copy of the License #
#  is located at                                                              #
#                                                                             #
#      http://www.apache.org/licenses/LICENSE-2.0/                            #
#                                                                             #
#  or in the \\"license\\" file accompanying this file. This file is distributed  #
#  on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, express #
#  or implied. See the License for the specific language governing permis-    #
#  sions and limitations under the License.                                   #
###############################################################################
 
import boto3
from botocore.config import Config
from botocore.exceptions import ClientError

boto_config = Config(
    retries ={
        'mode': 'standard'
    }
)

def connect_to_config(boto_config):
    return boto3.client('config', config=boto_config)

def create_config_recorder(aws_partition, aws_account, aws_service_role):
    cfgsvc = connect_to_config(boto_config)
    try:
        config_service_role_arn = 'arn:' + aws_partition + ':iam::' + aws_account + ':role/' + aws_service_role
        cfgsvc.put_configuration_recorder(
            ConfigurationRecorder={
                'name': 'default',
                'roleARN': config_service_role_arn,
                'recordingGroup': {
                    'allSupported': True,
                    'includeGlobalResourceTypes': True
                }
            }
        )
    except ClientError as ex:
        exception_type = ex.response['Error']['Code']
        # recorder already exists - continue
        if exception_type in [\\"MaxNumberOfConfigurationRecordersExceededException\\"]:
            print('Config Recorder already exists. Continuing.')
        else:
            exit(f'ERROR: Boto3 ClientError enabling Config: {exception_type} - {str(ex)}')
    except Exception as e:
        exit(f'ERROR enabling AWS Config - create_config_recorder: {str(e)}')

def create_delivery_channel(config_bucket, aws_account, topic_arn):
    cfgsvc = connect_to_config(boto_config)
    try:
        cfgsvc.put_delivery_channel(
            DeliveryChannel={
                'name': 'default',
                's3BucketName': config_bucket,
                's3KeyPrefix': aws_account,
                'snsTopicARN': topic_arn,
                'configSnapshotDeliveryProperties': {
                    'deliveryFrequency': 'Twelve_Hours'
                }
            }
        )
    except ClientError as ex:
        exception_type = ex.response['Error']['Code']
        # delivery channel already exists - return
        if exception_type in [\\"MaxNumberOfDeliveryChannelsExceededException\\"]:
            print('DeliveryChannel already exists')
        else:
            exit(f'ERROR: Boto3 ClientError enabling Config: {exception_type} - {str(ex)}')
    except Exception as e:
        exit(f'ERROR enabling AWS Config - create_delivery_channel: {str(e)}')

def start_recorder():
    cfgsvc = connect_to_config(boto_config)
    try:
        cfgsvc.start_configuration_recorder(
            ConfigurationRecorderName='default'
        )
    except Exception as e:
        exit(f'ERROR enabling AWS Config: {str(e)}')          

def enable_config(event, context):
    aws_account = event['account']
    aws_partition = event['partition']
    aws_service_role = event['aws_service_role']
    config_bucket = event['config_bucket']
    topic_arn = event['topic_arn']

    create_config_recorder(aws_partition, aws_account, aws_service_role)
    create_delivery_channel(config_bucket, aws_account, topic_arn)
    start_recorder()",
              },
              "isEnd": false,
              "name": "EnableConfig",
              "outputs": Array [
                Object {
                  "Name": "ConfigBucketName",
                  "Selector": "$.Payload.config_bucket",
                  "Type": "String",
                },
              ],
            },
            Object {
              "action": "aws:executeScript",
              "inputs": Object {
                "Handler": "process_results",
                "InputPayload": Object {
                  "config_bucket": "{{CreateConfigBucket.ConfigBucketName}}",
                  "logging_bucket": "so0111-accesslogs-{{global:ACCOUNT_ID}}-{{global:REGION}}",
                  "sns_topic_arn": "{{CreateTopic.TopicArn}}",
                },
                "Runtime": "python3.7",
                "Script": "#!/usr/bin/python
###############################################################################
#  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.         #
#                                                                             #
#  Licensed under the Apache License Version 2.0 (the \\"License\\"). You may not #
#  use this file except in compliance with the License. A copy of the License #
#  is located at                                                              #
#                                                                             #
#      http://www.apache.org/licenses/LICENSE-2.0/                            #
#                                                                             #
#  or in the \\"license\\" file accompanying this file. This file is distributed  #
#  on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, express #
#  or implied. See the License for the specific language governing permis-    #
#  sions and limitations under the License.                                   #
###############################################################################
 
def process_results(event, context):
    print(f'Created encrypted SNS topic {event[\\"sns_topic_arn\\"]}')
    print(f'Created encrypted Config bucket {event[\\"config_bucket\\"]}')
    print(f'Created access logging for Config bucket in bucket {event[\\"logging_bucket\\"]}')
    print('Enabled AWS Config by creating a default recorder')
    return {
        \\"response\\": {
            \\"message\\": \\"AWS Config successfully enabled\\",
            \\"status\\": \\"Success\\"
        }
    }",
              },
              "isEnd": true,
              "name": "Remediation",
              "outputs": Array [
                Object {
                  "Name": "Output",
                  "Selector": "$",
                  "Type": "StringMap",
                },
              ],
            },
          ],
          "outputs": Array [
            "Remediation.Output",
          ],
          "parameters": Object {
            "AWSServiceRoleForConfig": Object {
              "allowedPattern": "^(:?[\\\\w+=,.@-]+/)+[\\\\w+=,.@-]+$",
              "default": "aws-service-role/config.amazonaws.com/AWSServiceRoleForConfig",
              "type": "String",
            },
            "AutomationAssumeRole": Object {
              "allowedPattern": "^arn:(aws[a-zA-Z-]*)?:iam::\\\\d{12}:role/[\\\\w+=,.@-]+",
              "description": "(Required) The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that allows Systems Manager Automation to perform the actions on your behalf.",
              "type": "String",
            },
            "KMSKeyArn": Object {
              "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):kms:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\\\d):\\\\d{12}:(?:(?:alias/[A-Za-z0-9/-_])|(?:key/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})))$",
              "description": "The ARN of a KMS key to use for encryption of the SNS Topic and Config bucket",
              "type": "String",
            },
            "SNSTopicName": Object {
              "allowedPattern": "^[a-zA-Z0-9][a-zA-Z0-9-_]{0,255}$",
              "type": "String",
            },
          },
          "schemaVersion": "0.3",
        },
        "DocumentType": "Automation",
        "Name": "SHARR-EnableAWSConfig",
      },
      "Type": "AWS::SSM::Document",
    },
    "SHARREnableAutoScalingGroupELBHealthCheckAutomationDocumentB72D2528": Object {
      "Properties": Object {
        "Content": Object {
          "assumeRole": "{{ AutomationAssumeRole }}",
          "description": "### Document name - SHARR-EnableAutoScalingGroupELBHealthCheck

## What does this document do?
This runbook enables health checks for the Amazon EC2 Auto Scaling (Auto Scaling) group you specify using the [UpdateAutoScalingGroup](https://docs.aws.amazon.com/autoscaling/ec2/APIReference/API_UpdateAutoScalingGroup.html) API.

## Input Parameters
* AutomationAssumeRole: (Required) The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that allows Systems Manager Automation to perform the actions on your behalf.
* AutoScalingGroupARN: (Required) The Amazon Resource Name (ARN) of the auto scaling group that you want to enable health checks on.
* HealthCheckGracePeriod: (Optional) The amount of time, in seconds, that Auto Scaling waits before checking the health status of an Amazon Elastic Compute Cloud (Amazon EC2) instance that has come into service.

## Output Parameters

* Remediation.Output - stdout messages from the remediation

## Security Standards / Controls
* AFSBP v1.0.0: Autoscaling.1
* CIS v1.2.0:   2.1
* PCI:          Autoscaling.1
",
          "mainSteps": Array [
            Object {
              "action": "aws:executeAwsApi",
              "description": "Enable ELB health check type on ASG",
              "inputs": Object {
                "Api": "UpdateAutoScalingGroup",
                "AutoScalingGroupName": "{{AutoScalingGroupName}}",
                "HealthCheckGracePeriod": "{{HealthCheckGracePeriod}}",
                "HealthCheckType": "ELB",
                "Service": "autoscaling",
              },
              "name": "EnableELBHealthCheck",
              "outputs": Array [
                Object {
                  "Name": "Output",
                  "Selector": "$",
                  "Type": "StringMap",
                },
              ],
            },
            Object {
              "action": "aws:executeScript",
              "inputs": Object {
                "Handler": "verify",
                "InputPayload": Object {
                  "AsgName": "{{AutoScalingGroupName}}",
                },
                "Runtime": "python3.7",
                "Script": "#!/usr/bin/python
###############################################################################
#  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.    #
#                                                                             #
#  Licensed under the Apache License Version 2.0 (the \\"License\\"). You may not #
#  use this file except in compliance with the License. A copy of the License #
#  is located at                                                              #
#                                                                             #
#      http://www.apache.org/licenses/LICENSE-2.0/                                        #
#                                                                             #
#  or in the \\"license\\" file accompanying this file. This file is distributed  #
#  on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, express #
#  or implied. See the License for the specific language governing permis-    #
#  sions and limitations under the License.                                   #
###############################################################################

import json
import boto3
from botocore.config import Config
from botocore.exceptions import ClientError

def connect_to_autoscaling(boto_config):
    return boto3.client('autoscaling', config=boto_config)

def verify(event, context):

    boto_config = Config(
        retries ={
          'mode': 'standard'
        }
    )
    asg_client = connect_to_autoscaling(boto_config)
    asg_name = event['AsgName']
    try:
        desc_asg = asg_client.describe_auto_scaling_groups(
            AutoScalingGroupNames=[asg_name]
        )
        if len(desc_asg['AutoScalingGroups']) < 1:
            exit(f'No AutoScaling Group found matching {asg_name}')
            
        health_check = desc_asg['AutoScalingGroups'][0]['HealthCheckType']
        print(json.dumps(desc_asg['AutoScalingGroups'][0], default=str))
        if (health_check == 'ELB'):
            return {
                \\"response\\": {
                    \\"message\\": \\"Autoscaling Group health check type updated to ELB\\",
                    \\"status\\": \\"Success\\"
                }
            }
        else:
            return {
                \\"response\\": {
                    \\"message\\": \\"Autoscaling Group health check type is not ELB\\",
                    \\"status\\": \\"Failed\\"
                }
            }
    except Exception as e:
        exit(\\"Exception while executing remediation: \\" + str(e))",
              },
              "name": "Remediation",
              "outputs": Array [
                Object {
                  "Name": "Output",
                  "Selector": "$.Payload.response",
                  "Type": "StringMap",
                },
              ],
            },
          ],
          "outputs": Array [
            "Remediation.Output",
          ],
          "parameters": Object {
            "AutoScalingGroupName": Object {
              "allowedPattern": "^[\\\\u0020-\\\\uD7FF\\\\uE000-\\\\uFFFD\\\\uD800\\\\uDC00-\\\\uDBFF\\\\uDFFF]{1,255}$",
              "description": "(Required) The Amazon Resource Name (ARN) of the auto scaling group that you want to enable health checks on.",
              "type": "String",
            },
            "AutomationAssumeRole": Object {
              "allowedPattern": "^arn:(aws[a-zA-Z-]*)?:iam::\\\\d{12}:role/[\\\\w+=,.@/-]+$",
              "description": "(Required) The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that allows Systems Manager Automation to perform the actions on your behalf.",
              "type": "String",
            },
            "HealthCheckGracePeriod": Object {
              "allowedPattern": "^[0-9]\\\\d*$",
              "default": 300,
              "description": "(Optional) The amount of time, in seconds, that Auto Scaling waits before checking the health status of an Amazon Elastic Compute Cloud (Amazon EC2) instance that has come into service.",
              "type": "Integer",
            },
          },
          "schemaVersion": "0.3",
        },
        "DocumentType": "Automation",
        "Name": "SHARR-EnableAutoScalingGroupELBHealthCheck",
      },
      "Type": "AWS::SSM::Document",
    },
    "SHARREnableCloudTrailEncryptionAutomationDocumentE1C28DB6": Object {
      "Properties": Object {
        "Content": Object {
          "assumeRole": "{{ AutomationAssumeRole }}",
          "description": "### Document Name - SHARR-EnableCloudTrailEncryption
## What does this document do?
Enables encryption on a CloudTrail using the provided KMS CMK

## Input Parameters
* AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.
* KMSKeyArn (from SSM): Arn of the KMS key to be used to encrypt data
* TrailRegion: region of the CloudTrail to encrypt
* TrailArn: ARN of the CloudTrail to encrypt

## Security Standards / Controls
* AFSBP v1.0.0:   CloudTrail.2
* CIS v1.2.0:     2.7
* PCI:            CloudTrail.1
",
          "mainSteps": Array [
            Object {
              "action": "aws:executeScript",
              "inputs": Object {
                "Handler": "enable_trail_encryption",
                "InputPayload": Object {
                  "exec_region": "{{global:REGION}}",
                  "kms_key_arn": "{{KMSKeyArn}}",
                  "region": "{{global:REGION}}",
                  "trail": "{{TrailArn}}",
                  "trail_region": "{{TrailRegion}}",
                },
                "Runtime": "python3.7",
                "Script": "#!/usr/bin/python
###############################################################################
#  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.    #
#                                                                             #
#  Licensed under the Apache License Version 2.0 (the \\"License\\"). You may not #
#  use this file except in compliance with the License. A copy of the License #
#  is located at                                                              #
#                                                                             #
#      http://www.apache.org/licenses/LICENSE-2.0/                                        #
#                                                                             #
#  or in the \\"license\\" file accompanying this file. This file is distributed  #
#  on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, express #
#  or implied. See the License for the specific language governing permis-    #
#  sions and limitations under the License.                                   #
###############################################################################

import boto3
from botocore.config import Config
from botocore.exceptions import ClientError

def connect_to_cloudtrail(region, boto_config):
    return boto3.client('cloudtrail', region_name=region, config=boto_config)

def enable_trail_encryption(event, context):
    \\"\\"\\"
    remediates CloudTrail.2 by enabling SSE-KMS
    On success returns a string map
    On failure returns NoneType
    \\"\\"\\"
    boto_config = Config(
        retries ={
          'mode': 'standard'
        }
    )
  
    if event['trail_region'] != event['exec_region']:
        exit('ERROR: cross-region remediation is not yet supported')

    ctrail_client = connect_to_cloudtrail(event['trail_region'], boto_config)
    kms_key_arn = event['kms_key_arn'] 

    try:
        ctrail_client.update_trail(
            Name=event['trail'],
            KmsKeyId=kms_key_arn
        )
        return {
            \\"response\\": {
                \\"message\\": f'Enabled KMS CMK encryption on {event[\\"trail\\"]}',
                \\"status\\": \\"Success\\"
            }
        }
    except Exception as e:
        exit(f'Error enabling SSE-KMS encryption: {str(e)}')",
              },
              "isEnd": true,
              "name": "Remediation",
              "outputs": Array [
                Object {
                  "Name": "Output",
                  "Selector": "$.Payload.response",
                  "Type": "StringMap",
                },
              ],
            },
          ],
          "outputs": Array [
            "Remediation.Output",
          ],
          "parameters": Object {
            "AutomationAssumeRole": Object {
              "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\\\d{12}:role/[\\\\w+=,.@-]+",
              "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
              "type": "String",
            },
            "KMSKeyArn": Object {
              "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):kms:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\\\d):\\\\d{12}:(?:(?:alias/[A-Za-z0-9/-_])|(?:key/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})))$",
              "default": "{{ssm:/Solutions/SO0111/CMK_REMEDIATION_ARN}}",
              "description": "The ARN of the KMS key created by SHARR for this remediation",
              "type": "String",
            },
            "TrailArn": Object {
              "allowedPattern": "^arn:(?:aws|aws-cn|aws-us-gov):cloudtrail:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\\\d):\\\\d{12}:trail/[A-Za-z0-9._-]{3,128}$",
              "description": "ARN of the CloudTrail",
              "type": "String",
            },
            "TrailRegion": Object {
              "allowedPattern": "^[a-z]{2}(?:-gov)?-[a-z]+-\\\\d$",
              "description": "Region the CloudTrail is in",
              "type": "String",
            },
          },
          "schemaVersion": "0.3",
        },
        "DocumentType": "Automation",
        "Name": "SHARR-EnableCloudTrailEncryption",
      },
      "Type": "AWS::SSM::Document",
    },
    "SHARREnableCloudTrailLogFileValidationAutomationDocumentA3B13B24": Object {
      "Properties": Object {
        "Content": Object {
          "assumeRole": "{{ AutomationAssumeRole }}",
          "description": "### Document name - AWSConfigRemediation-EnableCloudTrailLogFileValidation

## What does this document do?
This runbook enables log file validation for your AWS CloudTrail trail using the [UpdateTrail](https://docs.aws.amazon.com/awscloudtrail/latest/APIReference/API_UpdateTrail.html) API.

## Input Parameters
* AutomationAssumeRole: (Required) The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that allows Systems Manager Automation to perform the actions on your behalf.
* TrailName: (Required) The name or Amazon Resource Name (ARN) of the trail you want to enable log file validation for.

## Output Parameters
* UpdateTrail.Output: The response of the UpdateTrail API call.

## Note: this is a local copy of the AWS-owned document to enable support in aws-cn and aws-us-gov partitions.
",
          "mainSteps": Array [
            Object {
              "action": "aws:executeAwsApi",
              "description": "## UpdateTrail
Enables log file validation for the AWS CloudTrail trail you specify in the TrailName parameter.
## Outputs
* Output: Response from the UpdateTrail API call.
",
              "inputs": Object {
                "Api": "UpdateTrail",
                "EnableLogFileValidation": true,
                "Name": "{{ TrailName }}",
                "Service": "cloudtrail",
              },
              "isEnd": false,
              "name": "UpdateTrail",
              "outputs": Array [
                Object {
                  "Name": "Output",
                  "Selector": "$",
                  "Type": "StringMap",
                },
              ],
              "timeoutSeconds": 600,
            },
            Object {
              "action": "aws:assertAwsResourceProperty",
              "description": "## VerifyTrail
Verifies log file validation is enabled for your trail.
",
              "inputs": Object {
                "Api": "GetTrail",
                "DesiredValues": Array [
                  "True",
                ],
                "Name": "{{ TrailName }}",
                "PropertySelector": "$.Trail.LogFileValidationEnabled",
                "Service": "cloudtrail",
              },
              "isEnd": true,
              "name": "VerifyTrail",
              "timeoutSeconds": 600,
            },
          ],
          "outputs": Array [
            "UpdateTrail.Output",
          ],
          "parameters": Object {
            "AutomationAssumeRole": Object {
              "allowedPattern": "^arn:(aws[a-zA-Z-]*)?:iam::\\\\d{12}:role/[\\\\w+=,.@-]+",
              "description": "(Required) The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that allows Systems Manager Automation to perform the actions on your behalf.",
              "type": "String",
            },
            "TrailName": Object {
              "allowedPattern": "(^arn:(aws[a-zA-Z-]*)?:cloudtrail:[a-z0-9-]+:\\\\d{12}:trail\\\\/(?![-_.])(?!.*[-_.]{2})(?!.*[-_.]$)(?!^\\\\d{1,3}\\\\.\\\\d{1,3}\\\\.\\\\d{1,3}\\\\.\\\\d{1,3}$)[-\\\\w.]{3,128}$)|(^(?![-_.])(?!.*[-_.]{2})(?!.*[-_.]$)(?!^\\\\d{1,3}\\\\.\\\\d{1,3}\\\\.\\\\d{1,3}\\\\.\\\\d{1,3}$)[-\\\\w.]{3,128}$)",
              "description": "(Required) The name or Amazon Resource Name (ARN) of the trail you want to enable log file validation for.",
              "type": "String",
            },
          },
          "schemaVersion": "0.3",
        },
        "DocumentType": "Automation",
        "Name": "SHARR-EnableCloudTrailLogFileValidation",
      },
      "Type": "AWS::SSM::Document",
    },
    "SHARREnableCloudTrailToCloudWatchLoggingAutomationDocument39CFB27F": Object {
      "Properties": Object {
        "Content": Object {
          "assumeRole": "{{ AutomationAssumeRole }}",
          "description": "### Document Name - SHARR-EnableCloudTrailToCloudWatchLogging
## What does this document do?
Creates a CloudWatch logs group for CloudTrail data.

## Input Parameters
* AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.
* KMSKeyArn (from SSM): Arn of the KMS key to be used to encrypt data

## Security Standards / Controls
* AFSBP v1.0.0:   N/A
* CIS v1.2.0:     2.4
* PCI:            CloudTrail.4
",
          "mainSteps": Array [
            Object {
              "action": "aws:executeAwsApi",
              "description": "Create the log group",
              "inputs": Object {
                "Api": "CreateLogGroup",
                "Service": "logs",
                "logGroupName": "{{LogGroupName}}",
              },
              "name": "CreateLogGroup",
              "outputs": Array [
                Object {
                  "Name": "Output",
                  "Selector": "$",
                  "Type": "StringMap",
                },
              ],
            },
            Object {
              "action": "aws:executeScript",
              "inputs": Object {
                "Handler": "wait_for_loggroup",
                "InputPayload": Object {
                  "LogGroup": "{{LogGroupName}}",
                },
                "Runtime": "python3.7",
                "Script": "#!/usr/bin/python
###############################################################################
#  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.    #
#                                                                             #
#  Licensed under the Apache License Version 2.0 (the \\"License\\"). You may not #
#  use this file except in compliance with the License. A copy of the License #
#  is located at                                                              #
#                                                                             #
#      http://www.apache.org/licenses/LICENSE-2.0/                                        #
#                                                                             #
#  or in the \\"license\\" file accompanying this file. This file is distributed  #
#  on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, express #
#  or implied. See the License for the specific language governing permis-    #
#  sions and limitations under the License.                                   #
###############################################################################

import boto3
from botocore.config import Config
import time

def connect_to_logs(boto_config):
    return boto3.client('logs', config=boto_config)

def wait_for_loggroup(event, context):
    boto_config = Config(
        retries ={
          'mode': 'standard'
        }
    )
    cwl_client = connect_to_logs(boto_config)

    max_retries = 3
    attempts = 0
    while attempts < max_retries:
        try:
            describe_group = cwl_client.describe_log_groups(logGroupNamePrefix=event['LogGroup'])
            print(len(describe_group['logGroups']))
            for group in describe_group['logGroups']:
                if group['logGroupName'] == event['LogGroup']:
                    return str(group['arn'])
            # no match - wait and retry
            time.sleep(2)
            attempts += 1

        except Exception as e:
            exit(f'Failed to create Log Group {event[\\"LogGroup\\"]}: {str(e)}')

    exit(f'Failed to create Log Group {event[\\"LogGroup\\"]}: Timed out')",
              },
              "isEnd": false,
              "name": "WaitForCreation",
              "outputs": Array [
                Object {
                  "Name": "CloudWatchLogsGroupArn",
                  "Selector": "$.Payload",
                  "Type": "String",
                },
              ],
            },
            Object {
              "action": "aws:executeAwsApi",
              "description": "Enable logging to CloudWatch Logs",
              "inputs": Object {
                "Api": "UpdateTrail",
                "CloudWatchLogsLogGroupArn": "{{WaitForCreation.CloudWatchLogsGroupArn}}",
                "CloudWatchLogsRoleArn": "{{CloudWatchLogsRole}}",
                "Name": "{{TrailName}}",
                "Service": "cloudtrail",
              },
              "name": "UpdateTrailToCWLogs",
              "outputs": Array [
                Object {
                  "Name": "Output",
                  "Selector": "$",
                  "Type": "StringMap",
                },
              ],
            },
          ],
          "outputs": Array [
            "UpdateTrailToCWLogs.Output",
          ],
          "parameters": Object {
            "AutomationAssumeRole": Object {
              "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\\\d{12}:role/[\\\\w+=,.@-]+",
              "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
              "type": "String",
            },
            "CloudWatchLogsRole": Object {
              "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\\\d{12}:role/[\\\\w+=,.@-]+",
              "description": "(Required) The ARN of the role that allows CloudTrail to log to CloudWatch.",
              "type": "String",
            },
            "LogGroupName": Object {
              "allowedPattern": "^[a-zA-Z0-9-_./]{1,512}$",
              "description": "(Required) The name of the Log Group for CloudTrail logs.",
              "type": "String",
            },
            "TrailName": Object {
              "allowedPattern": "^[A-Za-z0-9._-]{3,128}$",
              "description": "(Required) The name of the CloudTrail.",
              "type": "String",
            },
          },
          "schemaVersion": "0.3",
        },
        "DocumentType": "Automation",
        "Name": "SHARR-EnableCloudTrailToCloudWatchLogging",
      },
      "Type": "AWS::SSM::Document",
    },
    "SHARREnableEbsEncryptionByDefaultAutomationDocumentE19C88DF": Object {
      "Properties": Object {
        "Content": Object {
          "assumeRole": "{{ AutomationAssumeRole }}",
          "description": "### Document Name - AWSConfigRemediation-EnableEbsEncryptionByDefault

## What does this document do?
This document enables EBS encryption by default for an AWS account in the current region using the [EnableEbsEncryptionByDefault](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_EnableEbsEncryptionByDefault.html) API.

## Input Parameters
* AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.

## Output Parameters
* ModifyAccount.EnableEbsEncryptionByDefaultResponse: JSON formatted response from the EnableEbsEncryptionByDefault API.
",
          "mainSteps": Array [
            Object {
              "action": "aws:executeAwsApi",
              "description": "## ModifyAccount
Enables EBS encryption by default for the account in the current region.
## Outputs
* EnableEbsEncryptionByDefaultResponse: Response from the EnableEbsEncryptionByDefault API.
",
              "inputs": Object {
                "Api": "EnableEbsEncryptionByDefault",
                "Service": "ec2",
              },
              "isEnd": false,
              "name": "ModifyAccount",
              "outputs": Array [
                Object {
                  "Name": "EnableEbsEncryptionByDefaultResponse",
                  "Selector": "$",
                  "Type": "StringMap",
                },
              ],
              "timeoutSeconds": 600,
            },
            Object {
              "action": "aws:assertAwsResourceProperty",
              "description": "## VerifyEbsEncryptionByDefault
Checks if EbsEncryptionByDefault is enabled correctly from the previous step.
",
              "inputs": Object {
                "Api": "GetEbsEncryptionByDefault",
                "DesiredValues": Array [
                  "True",
                ],
                "PropertySelector": "$.EbsEncryptionByDefault",
                "Service": "ec2",
              },
              "isEnd": true,
              "name": "VerifyEbsEncryptionByDefault",
              "timeoutSeconds": 600,
            },
          ],
          "outputs": Array [
            "ModifyAccount.EnableEbsEncryptionByDefaultResponse",
          ],
          "parameters": Object {
            "AutomationAssumeRole": Object {
              "allowedPattern": "^arn:(aws[a-zA-Z-]*)?:iam::\\\\d{12}:role/[\\\\w+=,.@-]+$",
              "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
              "type": "String",
            },
          },
          "schemaVersion": "0.3",
        },
        "DocumentType": "Automation",
        "Name": "SHARR-EnableEbsEncryptionByDefault",
      },
      "Type": "AWS::SSM::Document",
    },
    "SHARREnableEnhancedMonitoringOnRDSInstanceAutomationDocumentF85DD852": Object {
      "Properties": Object {
        "Content": Object {
          "assumeRole": "{{ AutomationAssumeRole }}",
          "description": "### Document Name - AWSConfigRemediation-EnableEnhancedMonitoringOnRDSInstance

## What does this document do?
This document is used to enable enhanced monitoring on an RDS Instance using the input parameter DB Instance resourceId.

## Input Parameters
* ResourceId: (Required) Resource ID of the RDS DB Instance.
* MonitoringInterval: (Optional)
   * The interval, in seconds, between points when Enhanced Monitoring metrics are collected for the DB instance.
   * If MonitoringRoleArn is specified, then you must also set MonitoringInterval to a value other than 0.
   * Valid Values: 1, 5, 10, 15, 30, 60
   * Default: 60
* MonitoringRoleArn: (Required) The ARN for the IAM role that permits RDS to send enhanced monitoring metrics to Amazon CloudWatch Logs.
* AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.

## Output Parameters
* EnableEnhancedMonitoring.DbInstance - The standard HTTP response from the ModifyDBInstance API.
",
          "mainSteps": Array [
            Object {
              "action": "aws:executeAwsApi",
              "description": "## DescribeDBInstances
  Makes describeDBInstances API call using RDS Instance DbiResourceId to get DBInstanceId.
## Outputs
* DbInstanceIdentifier: DBInstance Identifier of the RDS Instance.
",
              "inputs": Object {
                "Api": "DescribeDBInstances",
                "Filters": Array [
                  Object {
                    "Name": "dbi-resource-id",
                    "Values": Array [
                      "{{ ResourceId }}",
                    ],
                  },
                ],
                "Service": "rds",
              },
              "isEnd": false,
              "name": "DescribeDBInstances",
              "outputs": Array [
                Object {
                  "Name": "DbInstanceIdentifier",
                  "Selector": "$.DBInstances[0].DBInstanceIdentifier",
                  "Type": "String",
                },
              ],
              "timeoutSeconds": 600,
            },
            Object {
              "action": "aws:assertAwsResourceProperty",
              "description": "## VerifyDBInstanceStatus
Verifies if DB Instance status is available before enabling enhanced monitoring.
",
              "inputs": Object {
                "Api": "DescribeDBInstances",
                "DBInstanceIdentifier": "{{ DescribeDBInstances.DbInstanceIdentifier }}",
                "DesiredValues": Array [
                  "available",
                ],
                "PropertySelector": "$.DBInstances[0].DBInstanceStatus",
                "Service": "rds",
              },
              "isEnd": false,
              "name": "VerifyDBInstanceStatus",
              "timeoutSeconds": 600,
            },
            Object {
              "action": "aws:executeAwsApi",
              "description": "## EnableEnhancedMonitoring
  Makes ModifyDBInstance API call to enable Enhanced Monitoring on the RDS Instance
  using the DBInstanceId from the previous action.
## Outputs
  * DbInstance: The standard HTTP response from the ModifyDBInstance API.
",
              "inputs": Object {
                "Api": "ModifyDBInstance",
                "ApplyImmediately": false,
                "DBInstanceIdentifier": "{{ DescribeDBInstances.DbInstanceIdentifier }}",
                "MonitoringInterval": "{{ MonitoringInterval }}",
                "MonitoringRoleArn": "{{ MonitoringRoleArn }}",
                "Service": "rds",
              },
              "isEnd": false,
              "name": "EnableEnhancedMonitoring",
              "outputs": Array [
                Object {
                  "Name": "DbInstance",
                  "Selector": "$",
                  "Type": "StringMap",
                },
              ],
              "timeoutSeconds": 600,
            },
            Object {
              "action": "aws:executeScript",
              "description": "## VerifyEnhancedMonitoringEnabled
Checks that the enhanced monitoring is enabled on RDS Instance in the previous step exists.
## Outputs
* Output: The standard HTTP response from the ModifyDBInstance API.
",
              "inputs": Object {
                "Handler": "handler",
                "InputPayload": Object {
                  "DBIdentifier": "{{ DescribeDBInstances.DbInstanceIdentifier }}",
                  "MonitoringInterval": "{{ MonitoringInterval }}",
                },
                "Runtime": "python3.7",
                "Script": "import boto3
import time

def handler(event, context):
    rds_client = boto3.client(\\"rds\\")
    db_instance_id = event[\\"DBIdentifier\\"]
    monitoring_interval = event[\\"MonitoringInterval\\"]

    try:
        rds_waiter = rds_client.get_waiter(\\"db_instance_available\\")
        rds_waiter.wait(DBInstanceIdentifier=db_instance_id)

        db_instances = rds_client.describe_db_instances(
            DBInstanceIdentifier=db_instance_id)

        for db_instance in db_instances.get(\\"DBInstances\\", [{}]):
            db_monitoring_interval = db_instance.get(\\"MonitoringInterval\\")

        if db_monitoring_interval == monitoring_interval:
            return {
                      \\"output\\": db_instances[\\"ResponseMetadata\\"]
                    }
        else:
            info = \\"VERIFICATION FAILED. RDS INSTANCE MONITORING INTERVAL {} IS NOT ENABLED WITH THE REQUIRED VALUE {}\\".format(
                    db_monitoring_interval, monitoring_interval)
            raise Exception(info)
    except Exception as e:
        raise e",
              },
              "isEnd": true,
              "name": "VerifyEnhancedMonitoringEnabled",
              "outputs": Array [
                Object {
                  "Name": "Output",
                  "Selector": "$.Payload.output",
                  "Type": "StringMap",
                },
              ],
              "timeoutSeconds": 600,
            },
          ],
          "outputs": Array [
            "EnableEnhancedMonitoring.DbInstance",
          ],
          "parameters": Object {
            "AutomationAssumeRole": Object {
              "allowedPattern": "^arn:(aws[a-zA-Z-]*)?:iam::\\\\d{12}:role/[a-zA-Z0-9+=,.@_/-]+$",
              "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
              "type": "String",
            },
            "MonitoringInterval": Object {
              "allowedValues": Array [
                1,
                5,
                10,
                15,
                30,
                60,
              ],
              "default": 60,
              "description": "(Optional) The interval, in seconds, between points when Enhanced Monitoring metrics are collected for the DB instance.",
              "type": "Integer",
            },
            "MonitoringRoleArn": Object {
              "allowedPattern": "^arn:(aws[a-zA-Z-]*)?:iam::\\\\d{12}:role/[a-zA-Z0-9+=,.@_/-]+$",
              "description": "(Required) The ARN for the IAM role that permits RDS to send enhanced monitoring metrics to Amazon CloudWatch Logs.",
              "type": "String",
            },
            "ResourceId": Object {
              "allowedPattern": "db-[A-Z0-9]{26}",
              "description": "(Required) Resource ID of the Amazon RDS instance for which Enhanced Monitoring needs to be enabled.",
              "type": "String",
            },
          },
          "schemaVersion": "0.3",
        },
        "DocumentType": "Automation",
        "Name": "SHARR-EnableEnhancedMonitoringOnRDSInstance",
      },
      "Type": "AWS::SSM::Document",
    },
    "SHARREnableKeyRotationAutomationDocumentAFF68728": Object {
      "Properties": Object {
        "Content": Object {
          "assumeRole": "{{ AutomationAssumeRole }}",
          "description": "### Document name - AWSConfigRemediation-EnableKeyRotation

## What does this document do?
This document enables automatic key rotation for the given AWS Key Management Service (KMS) symmetric customer master key(CMK) using [EnableKeyRotation](https://docs.aws.amazon.com/kms/latest/APIReference/API_EnableKeyRotation.html) API.

## Input Parameters
* AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.
* KeyId: (Required) The Key ID of the AWS KMS symmetric CMK.

## Output Parameters
* EnableKeyRotation.EnableKeyRotationResponse: The standard HTTP response from the EnableKeyRotation API.
",
          "mainSteps": Array [
            Object {
              "action": "aws:executeAwsApi",
              "description": "## EnableKeyRotation
Enables automatic key rotation for the given AWS KMS CMK.
## Outputs
* EnableKeyRotationResponse: The standard HTTP response from the EnableKeyRotation API.
",
              "inputs": Object {
                "Api": "EnableKeyRotation",
                "KeyId": "{{ KeyId }}",
                "Service": "kms",
              },
              "isEnd": false,
              "name": "EnableKeyRotation",
              "outputs": Array [
                Object {
                  "Name": "EnableKeyRotationResponse",
                  "Selector": "$",
                  "Type": "StringMap",
                },
              ],
              "timeoutSeconds": 600,
            },
            Object {
              "action": "aws:assertAwsResourceProperty",
              "description": "## VerifyKeyRotation
Verifies that the KeyRotationEnabled is set to true for the given AWS KMS CMK.
",
              "inputs": Object {
                "Api": "GetKeyRotationStatus",
                "DesiredValues": Array [
                  "True",
                ],
                "KeyId": "{{ KeyId }}",
                "PropertySelector": "$.KeyRotationEnabled",
                "Service": "kms",
              },
              "isEnd": true,
              "name": "VerifyKeyRotation",
              "timeoutSeconds": 600,
            },
          ],
          "outputs": Array [
            "EnableKeyRotation.EnableKeyRotationResponse",
          ],
          "parameters": Object {
            "AutomationAssumeRole": Object {
              "allowedPattern": "^arn:(aws[a-zA-Z-]*)?:iam::\\\\d{12}:role/[\\\\w+=,.@/-]+$",
              "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
              "type": "String",
            },
            "KeyId": Object {
              "allowedPattern": "[a-z0-9-]{1,2048}",
              "description": "(Required) The Key ID of the AWS KMS symmetric CMK.",
              "type": "String",
            },
          },
          "schemaVersion": "0.3",
        },
        "DocumentType": "Automation",
        "Name": "SHARR-EnableKeyRotation",
      },
      "Type": "AWS::SSM::Document",
    },
    "SHARREnableRDSClusterDeletionProtectionAutomationDocumentBA07C167": Object {
      "Properties": Object {
        "Content": Object {
          "assumeRole": "{{ AutomationAssumeRole }}",
          "description": "### Document name - AWSConfigRemediation-EnableRDSClusterDeletionProtection

## What does this document do?
This document enables \`Deletion Protection\` on a given Amazon RDS cluster using the [ModifyDBCluster](https://docs.aws.amazon.com/AmazonRDS/latest/APIReference/API_ModifyDBCluster.html) API.
Please note, AWS Config is required to be enabled in this region for this document to work as it requires the resource ID recorded by the AWS Config service.

## Input Parameters
* AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.
* ClusterId: (Required) Resource ID of the Amazon RDS cluster.

## Output Parameters
* EnableRDSClusterDeletionProtection.ModifyDBClusterResponse: The standard HTTP response from the ModifyDBCluster API.
",
          "mainSteps": Array [
            Object {
              "action": "aws:executeAwsApi",
              "description": "## GetRDSClusterIdentifer
Accepts the resource ID of the Amazon RDS Cluster as input and returns the cluster name.
## Outputs
* DbClusterIdentifier: The ID of the DB cluster for which the input parameter matches DbClusterResourceId element from the output of the DescribeDBClusters API call.
",
              "inputs": Object {
                "Api": "GetResourceConfigHistory",
                "Service": "config",
                "limit": 1,
                "resourceId": "{{ ClusterId }}",
                "resourceType": "AWS::RDS::DBCluster",
              },
              "isEnd": false,
              "name": "GetRDSClusterIdentifer",
              "outputs": Array [
                Object {
                  "Name": "DbClusterIdentifier",
                  "Selector": "$.configurationItems[0].resourceName",
                  "Type": "String",
                },
              ],
              "timeoutSeconds": 600,
            },
            Object {
              "action": "aws:assertAwsResourceProperty",
              "description": "## VerifyDBClusterStatus
Verifies if the DB Cluster status is available before enabling cluster deletion protection.
",
              "inputs": Object {
                "Api": "DescribeDBClusters",
                "DBClusterIdentifier": "{{ GetRDSClusterIdentifer.DbClusterIdentifier }}",
                "DesiredValues": Array [
                  "available",
                ],
                "PropertySelector": "$.DBClusters[0].Status",
                "Service": "rds",
              },
              "isEnd": false,
              "name": "VerifyDBClusterStatus",
              "timeoutSeconds": 600,
            },
            Object {
              "action": "aws:executeAwsApi",
              "description": "## EnableRDSClusterDeletionProtection
Enables deletion protection on the Amazon RDS Cluster.
## Outputs
* ModifyDBClusterResponse: The standard HTTP response from the ModifyDBCluster API.
",
              "inputs": Object {
                "Api": "ModifyDBCluster",
                "DBClusterIdentifier": "{{ GetRDSClusterIdentifer.DbClusterIdentifier }}",
                "DeletionProtection": true,
                "Service": "rds",
              },
              "isEnd": false,
              "name": "EnableRDSClusterDeletionProtection",
              "outputs": Array [
                Object {
                  "Name": "ModifyDBClusterResponse",
                  "Selector": "$",
                  "Type": "StringMap",
                },
              ],
              "timeoutSeconds": 600,
            },
            Object {
              "action": "aws:assertAwsResourceProperty",
              "description": "## VerifyDBClusterModification
Verifies that deletion protection has been enabled for the given Amazon RDS database cluster.
",
              "inputs": Object {
                "Api": "DescribeDBClusters",
                "DBClusterIdentifier": "{{ GetRDSClusterIdentifer.DbClusterIdentifier }}",
                "DesiredValues": Array [
                  "True",
                ],
                "PropertySelector": "$.DBClusters[0].DeletionProtection",
                "Service": "rds",
              },
              "isEnd": true,
              "name": "VerifyDBClusterModification",
              "timeoutSeconds": 600,
            },
          ],
          "outputs": Array [
            "EnableRDSClusterDeletionProtection.ModifyDBClusterResponse",
          ],
          "parameters": Object {
            "AutomationAssumeRole": Object {
              "allowedPattern": "^arn:(aws[a-zA-Z-]*)?:iam::\\\\d{12}:role/[\\\\w+=,.@-]+",
              "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
              "type": "String",
            },
            "ClusterId": Object {
              "allowedPattern": "^[a-zA-Z0-9-]{1,35}$",
              "description": "(Required) Amazon RDS cluster resourceId for which deletion protection needs to be enabled.",
              "type": "String",
            },
          },
          "schemaVersion": "0.3",
        },
        "DocumentType": "Automation",
        "Name": "SHARR-EnableRDSClusterDeletionProtection",
      },
      "Type": "AWS::SSM::Document",
    },
    "SHARREnableVPCFlowLogsAutomationDocument450A4332": Object {
      "Properties": Object {
        "Content": Object {
          "assumeRole": "{{ AutomationAssumeRole }}",
          "description": "### Document Name - SHARR-EnableVPCFlowLogs
## What does this document do?
Enables VPC Flow Logs for a given VPC

## Input Parameters
* AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.
* VPC: VPC Id of the VPC for which logs are to be enabled
* RemediationRole: role arn of the role to use for logging
* KMSKeyArn: Amazon Resource Name (ARN) of the KMS Customer-Managed Key to use to encrypt the log group

## Security Standards / Controls
* AFSBP v1.0.0:   CloudTrail.2
* CIS v1.2.0:     2.7
* PCI:            CloudTrail.1
",
          "mainSteps": Array [
            Object {
              "action": "aws:executeScript",
              "inputs": Object {
                "Handler": "enable_flow_logs",
                "InputPayload": Object {
                  "kms_key_arn": "{{KMSKeyArn}}",
                  "remediation_role": "{{RemediationRole}}",
                  "vpc": "{{VPC}}",
                },
                "Runtime": "python3.7",
                "Script": "#!/usr/bin/python
###############################################################################
#  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.    #
#                                                                             #
#  Licensed under the Apache License Version 2.0 (the \\"License\\"). You may not #
#  use this file except in compliance with the License. A copy of the License #
#  is located at                                                              #
#                                                                             #
#      http://www.apache.org/licenses/LICENSE-2.0/                                        #
#                                                                             #
#  or in the \\"license\\" file accompanying this file. This file is distributed  #
#  on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, express #
#  or implied. See the License for the specific language governing permis-    #
#  sions and limitations under the License.                                   #
###############################################################################

import boto3
import time
from botocore.config import Config
from botocore.exceptions import ClientError

def connect_to_logs(boto_config):
    return boto3.client('logs', config=boto_config)

def connect_to_ec2(boto_config):
    return boto3.client('ec2', config=boto_config)

def log_group_exists(client, group):
    try:
        log_group_verification = client.describe_log_groups(
            logGroupNamePrefix=group
        )['logGroups']
        if len(log_group_verification) >= 1:
            for existing_loggroup in log_group_verification:
                if existing_loggroup['logGroupName'] == group:
                    return 1
        return 0

    except Exception as e:
        exit(f'EnableVPCFlowLogs failed - unhandled exception {str(e)}')

def wait_for_loggroup(client, wait_interval, max_retries, loggroup):
    attempts = 1
    while not log_group_exists(client, loggroup):
        time.sleep(wait_interval)
        attempts += 1
        if attempts > max_retries:
            exit(f'Timeout waiting for log group {loggroup} to become active')

def flowlogs_active(client, loggroup):
    # searches for flow log status, filtered on unique CW Log Group created earlier
    try:
        flow_status = client.describe_flow_logs(
            DryRun=False,
            Filters=[
                {
                    'Name': 'log-group-name',
                    'Values': [loggroup]
                },
            ]
        )['FlowLogs']
        if len(flow_status) == 1 and flow_status[0]['FlowLogStatus'] == 'ACTIVE':
            return 1
        else:
            return 0

    except Exception as e:
        exit(f'EnableVPCFlowLogs failed - unhandled exception {str(e)}')

def wait_for_flowlogs(client, wait_interval, max_retries, loggroup):
    attempts = 1
    while not flowlogs_active(client, loggroup):
        time.sleep(wait_interval)
        attempts += 1
        if attempts > max_retries:
            exit(f'Timeout waiting for flowlogs to log group {loggroup} to become active')

def enable_flow_logs(event, context):
    \\"\\"\\"
    remediates CloudTrail.2 by enabling SSE-KMS
    On success returns a string map
    On failure returns NoneType
    \\"\\"\\"
    max_retries = event.get('retries', 12) # max number of waits for actions to complete.
    wait_interval = event.get('wait', 5) # how many seconds between attempts

    boto_config_args = {
        'retries': {
            'mode': 'standard'
        }
    }

    boto_config = Config(**boto_config_args)

    if 'vpc' not in event or 'remediation_role' not in event or 'kms_key_arn' not in event:
        exit('Error: missing vpc from input')

    logs_client = connect_to_logs(boto_config)
    ec2_client = connect_to_ec2(boto_config)
    
    kms_key_arn = event['kms_key_arn'] # for logs encryption at rest
    
    # set dynamic variable for CW Log Group for VPC Flow Logs
    vpc_flow_loggroup = \\"VPCFlowLogs/\\" + event['vpc']        
    # create cloudwatch log group
    try:
        logs_client.create_log_group(
            logGroupName=vpc_flow_loggroup,
            kmsKeyId=kms_key_arn
        )
    except ClientError as client_error:
        exception_type = client_error.response['Error']['Code']

        if exception_type in [\\"ResourceAlreadyExistsException\\"]:
            print(f'CloudWatch Logs group {vpc_flow_loggroup} already exists')
        else:
            exit(f'ERROR CREATING LOGGROUP {vpc_flow_loggroup}: {str(exception_type)}')
            
    except Exception as e:
        exit(f'ERROR CREATING LOGGROUP {vpc_flow_loggroup}: {str(e)}')

    # wait for CWL creation to propagate
    wait_for_loggroup(logs_client, wait_interval, max_retries, vpc_flow_loggroup)

    # create VPC Flow Logging
    try:
        ec2_client.create_flow_logs(
            DryRun=False,
            DeliverLogsPermissionArn=event['remediation_role'],
            LogGroupName=vpc_flow_loggroup,
            ResourceIds=[event['vpc']],
            ResourceType='VPC',
            TrafficType='REJECT',
            LogDestinationType='cloud-watch-logs'
        )
    except ClientError as client_error:
        exception_type = client_error.response['Error']['Code']

        if exception_type in [\\"FlowLogAlreadyExists\\"]:
            return {
                \\"response\\": {
                    \\"message\\": f'VPC Flow Logs for {event[\\"vpc\\"]} already enabled',
                    \\"status\\": \\"Success\\"
                }
            }
        else:
            exit(f'ERROR CREATING LOGGROUP {vpc_flow_loggroup}: {str(exception_type)}')
    except Exception as e:
        exit(f'create_flow_logs failed {str(e)}')

    # wait for Flow Log creation to propagate. Exits on timeout (no need to check results)
    wait_for_flowlogs(ec2_client, wait_interval, max_retries, vpc_flow_loggroup)

    # wait_for_flowlogs will exit if unsuccessful after max_retries * wait_interval (60 seconds by default)
    return {
        \\"response\\": {
            \\"message\\": f'VPC Flow Logs enabled for {event[\\"vpc\\"]} to {vpc_flow_loggroup}',
            \\"status\\": \\"Success\\"
        }
    }",
              },
              "isEnd": true,
              "name": "Remediation",
              "outputs": Array [
                Object {
                  "Name": "Output",
                  "Selector": "$.Payload.response",
                  "Type": "StringMap",
                },
              ],
            },
          ],
          "outputs": Array [
            "Remediation.Output",
          ],
          "parameters": Object {
            "AutomationAssumeRole": Object {
              "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\\\d{12}:role/[\\\\w+=,.@-]+",
              "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
              "type": "String",
            },
            "KMSKeyArn": Object {
              "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):kms:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\\\d):\\\\d{12}:(?:(?:alias/[A-Za-z0-9/-_])|(?:key/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})))$",
              "default": "{{ssm:/Solutions/SO0111/CMK_REMEDIATION_ARN}}",
              "description": "The ARN of the KMS key created by SHARR for remediations requiring encryption",
              "type": "String",
            },
            "RemediationRole": Object {
              "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\\\d{12}:role/[\\\\w+=,.@-]+",
              "description": "The ARN of the role that will allow VPC Flow Logs to log to CloudWatch logs",
              "type": "String",
            },
            "VPC": Object {
              "allowedPattern": "^vpc-[0-9a-f]{8,17}",
              "description": "The VPC ID of the VPC",
              "type": "String",
            },
          },
          "schemaVersion": "0.3",
        },
        "DocumentType": "Automation",
        "Name": "SHARR-EnableVPCFlowLogs",
      },
      "Type": "AWS::SSM::Document",
    },
    "SHARRMakeEBSSnapshotsPrivateAutomationDocumentE34DB88E": Object {
      "Properties": Object {
        "Content": Object {
          "assumeRole": "{{ AutomationAssumeRole }}",
          "description": "### Document name - SHARR-MakeEBSSnapshotPrivate

## What does this document do?
This runbook works an the account level to remove public share on all EBS snapshots

## Input Parameters
* AutomationAssumeRole: (Required) The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that allows Systems Manager Automation to perform the actions on your behalf.

## Output Parameters

* Remediation.Output - stdout messages from the remediation

## Security Standards / Controls
* AFSBP v1.0.0: EC2.1
* CIS v1.2.0:   n/a
* PCI:          EC2.1
",
          "mainSteps": Array [
            Object {
              "action": "aws:executeScript",
              "inputs": Object {
                "Handler": "get_public_snapshots",
                "InputPayload": Object {
                  "account_id": "{{AccountId}}",
                  "region": "{{global:REGION}}",
                  "testmode": "{{TestMode}}",
                },
                "Runtime": "python3.7",
                "Script": "#!/usr/bin/python
###############################################################################
#  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.         #
#                                                                             #
#  Licensed under the Apache License Version 2.0 (the \\"License\\"). You may not #
#  use this file except in compliance with the License. A copy of the License #
#  is located at                                                              #
#                                                                             #
#      http://www.apache.org/licenses/LICENSE-2.0/                            #
#                                                                             #
#  or in the \\"license\\" file accompanying this file. This file is distributed  #
#  on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, express #
#  or implied. See the License for the specific language governing permis-    #
#  sions and limitations under the License.                                   #
###############################################################################

import json
import boto3
from botocore.config import Config
from botocore.exceptions import ClientError

boto_config = Config(
    retries = {
            'mode': 'standard',
            'max_attempts': 10
        }
    )

def connect_to_ec2(boto_config):
    return boto3.client('ec2', config=boto_config)

def get_public_snapshots(event, context):
    account_id = event['account_id']

    if 'testmode' in event and event['testmode']:
        return [
            \\"snap-12341234123412345\\",
            \\"snap-12341234123412345\\",
            \\"snap-12341234123412345\\",
            \\"snap-12341234123412345\\",
            \\"snap-12341234123412345\\"
        ]

    return list_public_snapshots(account_id)

def list_public_snapshots(account_id):
    ec2 = connect_to_ec2(boto_config)
    control_token = 'start'
    try:

        public_snapshot_ids = []

        while control_token:

            if control_token == 'start': # needed a value to start the loop. Now reset it
                control_token = ''

            kwargs = {
                'MaxResults': 100, 
                'OwnerIds': [ account_id ],
                'RestorableByUserIds': [ 'all' ]
            }
            if control_token:
                kwargs['NextToken'] = control_token
                
            response = ec2.describe_snapshots(
                        **kwargs
                )
        
            for snapshot in response['Snapshots']:
                public_snapshot_ids.append(snapshot['SnapshotId'])

            if 'NextToken' in response:
                control_token = response['NextToken']
            else:
                control_token = ''

        return public_snapshot_ids
        
    except Exception as e:
        print(e)
        exit('Failed to describe_snapshots')",
              },
              "name": "GetPublicSnapshotIds",
              "outputs": Array [
                Object {
                  "Name": "Snapshots",
                  "Selector": "$.Payload",
                  "Type": "StringList",
                },
              ],
            },
            Object {
              "action": "aws:executeScript",
              "inputs": Object {
                "Handler": "make_snapshots_private",
                "InputPayload": Object {
                  "region": "{{global:REGION}}",
                  "snapshots": "{{GetPublicSnapshotIds.Snapshots}}",
                },
                "Runtime": "python3.7",
                "Script": "#!/usr/bin/python
###############################################################################
#  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.         #
#                                                                             #
#  Licensed under the Apache License Version 2.0 (the \\"License\\"). You may not #
#  use this file except in compliance with the License. A copy of the License #
#  is located at                                                              #
#                                                                             #
#      http://www.apache.org/licenses/LICENSE-2.0/                            #
#                                                                             #
#  or in the \\"license\\" file accompanying this file. This file is distributed  #
#  on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, express #
#  or implied. See the License for the specific language governing permis-    #
#  sions and limitations under the License.                                   #
###############################################################################

import json
import boto3
from botocore.config import Config
from botocore.exceptions import ClientError

def connect_to_ec2(boto_config):
    return boto3.client('ec2', config=boto_config)

def make_snapshots_private(event, context):
    boto_config = Config(
        retries = {
                'mode': 'standard',
                'max_attempts': 10
            }
        )
    ec2 = connect_to_ec2(boto_config)

    remediated = []
    snapshots = event['snapshots']

    success_count = 0
    
    for snapshot_id in snapshots:
        try:
            ec2.modify_snapshot_attribute(
                Attribute='CreateVolumePermission',
                CreateVolumePermission={
                    'Remove': [{'Group': 'all'}]
                },
                SnapshotId=snapshot_id
            )
            print(f'Snapshot {snapshot_id} permissions set to private')

            remediated.append(snapshot_id)
            success_count += 1
        except Exception as e:
            print(e)
            print(f'FAILED to remediate Snapshot {snapshot_id}')

    result=json.dumps(ec2.describe_snapshots(
            SnapshotIds=remediated
        ), indent=2, default=str)
    print(result)

    return {
        \\"response\\": {
            \\"message\\": f'{success_count} of {len(snapshots)} Snapshot permissions set to private',
            \\"status\\": \\"Success\\"
        }
    }",
              },
              "name": "Remediation",
              "outputs": Array [
                Object {
                  "Name": "Output",
                  "Selector": "$.Payload.response",
                  "Type": "StringMap",
                },
              ],
            },
          ],
          "outputs": Array [
            "Remediation.Output",
          ],
          "parameters": Object {
            "AccountId": Object {
              "allowedPattern": "^[0-9]{12}$",
              "description": "Account ID of the account for which snapshots are to be checked.",
              "type": "String",
            },
            "AutomationAssumeRole": Object {
              "allowedPattern": "^arn:(aws[a-zA-Z-]*)?:iam::\\\\d{12}:role/[\\\\w+=,.@/-]+$",
              "description": "(Required) The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that allows Systems Manager Automation to perform the actions on your behalf.",
              "type": "String",
            },
            "TestMode": Object {
              "default": false,
              "description": "Enables test mode, which generates a list of fake volume Ids",
              "type": "Boolean",
            },
          },
          "schemaVersion": "0.3",
        },
        "DocumentType": "Automation",
        "Name": "SHARR-MakeEBSSnapshotsPrivate",
      },
      "Type": "AWS::SSM::Document",
    },
    "SHARRMakeRDSSnapshotPrivateAutomationDocumentD9111EA7": Object {
      "Properties": Object {
        "Content": Object {
          "assumeRole": "{{ AutomationAssumeRole }}",
          "description": "### Document name - SHARR-MakeRDSSnapshotPrivate

## What does this document do?
This runbook removes public access to an RDS Snapshot

## Input Parameters
* AutomationAssumeRole: (Required) The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that allows Systems Manager Automation to perform the actions on your behalf.
* DBSnapshotId: identifier of the public snapshot
* DBSnapshotType: snapshot or cluster-snapshot

## Output Parameters

* Remediation.Output - stdout messages from the remediation

## Security Standards / Controls
* AFSBP v1.0.0: RDS.1
* CIS v1.2.0:   n/a
* PCI:          RDS.1
",
          "mainSteps": Array [
            Object {
              "action": "aws:executeScript",
              "inputs": Object {
                "Handler": "make_snapshot_private",
                "InputPayload": Object {
                  "DBSnapshotId": "{{DBSnapshotId}}",
                  "DBSnapshotType": "{{DBSnapshotType}}",
                },
                "Runtime": "python3.7",
                "Script": "#!/usr/bin/python
###############################################################################
#  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.         #
#                                                                             #
#  Licensed under the Apache License Version 2.0 (the \\"License\\"). You may not #
#  use this file except in compliance with the License. A copy of the License #
#  is located at                                                              #
#                                                                             #
#      http://www.apache.org/licenses/LICENSE-2.0/                            #
#                                                                             #
#  or in the \\"license\\" file accompanying this file. This file is distributed  #
#  on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, express #
#  or implied. See the License for the specific language governing permis-    #
#  sions and limitations under the License.                                   #
###############################################################################

import json
import boto3
from botocore.config import Config
from botocore.exceptions import ClientError

def connect_to_rds():
    boto_config = Config(
        retries ={
            'mode': 'standard'
        }
    )
    return boto3.client('rds', config=boto_config)

def make_snapshot_private(event, context):

    rds_client = connect_to_rds()
    snapshot_id = event['DBSnapshotId']
    snapshot_type = event['DBSnapshotType']
    try:
        if (snapshot_type == 'snapshot'):
            rds_client.modify_db_snapshot_attribute(
                DBSnapshotIdentifier=snapshot_id,
                AttributeName='restore',
                ValuesToRemove=['all']
            )
        elif (snapshot_type == 'cluster-snapshot'):
            rds_client.modify_db_cluster_snapshot_attribute(
                DBClusterSnapshotIdentifier=snapshot_id,
                AttributeName='restore',
                ValuesToRemove=['all']
            )
        else:
            exit(f'Unrecognized snapshot_type {snapshot_type}')

        print(f'Remediation completed: {snapshot_id} public access removed.')
        return {
            \\"response\\": {
                \\"message\\": f'Snapshot {snapshot_id} permissions set to private',
                \\"status\\": \\"Success\\"
            }
        }
    except Exception as e:
        exit(f'Remediation failed for {snapshot_id}: {str(e)}')",
              },
              "name": "MakeRDSSnapshotPrivate",
              "outputs": Array [
                Object {
                  "Name": "Output",
                  "Selector": "$.Payload.response",
                  "Type": "StringMap",
                },
              ],
            },
          ],
          "outputs": Array [
            "MakeRDSSnapshotPrivate.Output",
          ],
          "parameters": Object {
            "AutomationAssumeRole": Object {
              "allowedPattern": "^arn:(aws[a-zA-Z-]*)?:iam::\\\\d{12}:role/[\\\\w+=,.@/-]+$",
              "description": "(Required) The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that allows Systems Manager Automation to perform the actions on your behalf.",
              "type": "String",
            },
            "DBSnapshotId": Object {
              "allowedPattern": "^[a-zA-Z](?:[0-9a-zA-Z]+[-]{1})*[0-9a-zA-Z]{1,}$",
              "type": "String",
            },
            "DBSnapshotType": Object {
              "allowedValues": Array [
                "cluster-snapshot",
                "snapshot",
              ],
              "type": "String",
            },
          },
          "schemaVersion": "0.3",
        },
        "DocumentType": "Automation",
        "Name": "SHARR-MakeRDSSnapshotPrivate",
      },
      "Type": "AWS::SSM::Document",
    },
    "SHARRRemoveLambdaPublicAccessAutomationDocumentB33C7F4F": Object {
      "Properties": Object {
        "Content": Object {
          "assumeRole": "{{ AutomationAssumeRole }}",
          "description": "### Document name - SHARR-RemoveLambdaPublicAccess

## What does this document do?
This document removes the public resource policy. A public resource policy
contains a principal \\"*\\" or AWS: \\"*\\", which allows public access to the 
function. The remediation is to remove the SID of the public policy.

## Input Parameters
* FunctionName: name of the AWS Lambda function that has open access policies
* AutomationAssumeRole: (Required) The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that allows Systems Manager Automation to perform the actions on your behalf.

## Output Parameters

* RemoveLambdaPublicAccess.Output - stdout messages from the remediation

## Security Standards / Controls
* AFSBP v1.0.0: Lambda.1
* CIS v1.2.0:   n/a
* PCI:          Lambda.1
",
          "mainSteps": Array [
            Object {
              "action": "aws:executeScript",
              "inputs": Object {
                "Handler": "remove_lambda_public_access",
                "InputPayload": Object {
                  "FunctionName": "{{FunctionName}}",
                },
                "Runtime": "python3.7",
                "Script": "#!/usr/bin/python
###############################################################################
#  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.         #
#                                                                             #
#  Licensed under the Apache License Version 2.0 (the \\"License\\"). You may not #
#  use this file except in compliance with the License. A copy of the License #
#  is located at                                                              #
#                                                                             #
#      http://www.apache.org/licenses/LICENSE-2.0/                            #
#                                                                             #
#  or in the \\"license\\" file accompanying this file. This file is distributed  #
#  on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, express #
#  or implied. See the License for the specific language governing permis-    #
#  sions and limitations under the License.                                   #
###############################################################################

import json
import boto3
from botocore.config import Config
from botocore.exceptions import ClientError

boto_config = Config(
    retries = {
        'mode': 'standard',
        'max_attempts': 10
    }
)

def connect_to_lambda(boto_config):
    return boto3.client('lambda', config=boto_config)

def print_policy_before(policy):
    print('Resource Policy to be deleted:')
    print(json.dumps(policy, indent=2, default=str))

def remove_resource_policy(functionname, sid, client):
    try:
        client.remove_permission(
            FunctionName=functionname,
            StatementId=sid
        )
        print(f'SID {sid} removed from Lambda function {functionname}')
    except Exception as e:
        exit(f'FAILED: SID {sid} was NOT removed from Lambda function {functionname} - {str(e)}')

def remove_public_statement(client, functionname, statement, principal_source):
    for principal in list(principal_source):
        if principal == \\"*\\" or (isinstance(principal, dict) and principal.get(\\"AWS\\",\\"\\") == \\"*\\"):
            print_policy_before(statement)
            remove_resource_policy(functionname, statement['Sid'], client)
            break # there will only be one that matches

def remove_lambda_public_access(event, context):

    client = connect_to_lambda(boto_config)

    functionname = event['FunctionName']
    try:
        response = client.get_policy(FunctionName=functionname)
        policy = response['Policy']
        policy_json = json.loads(policy)
        statements = policy_json['Statement']

        print('Scanning for public resource policies in ' + functionname)

        for statement in statements:
            remove_public_statement(client, functionname, statement, list(statement['Principal']))

        client.get_policy(FunctionName=functionname)

        verify(functionname)
    except ClientError as ex:
        exception_type = ex.response['Error']['Code']
        if exception_type in ['ResourceNotFoundException']:
            print(\\"Remediation completed. Resource policy is now empty.\\")
        else:
            exit(f'ERROR: Remediation failed for RemoveLambdaPublicAccess: {str(ex)}')
    except Exception as e:
        exit(f'ERROR: Remediation failed for RemoveLambdaPublicAccess: {str(e)}')

def verify(function_name_to_check):

    client = connect_to_lambda(boto_config)

    try:
        response = client.get_policy(FunctionName=function_name_to_check)

        print(\\"Remediation executed successfully. Policy after:\\")
        print(json.dumps(response, indent=2, default=str))
        
    except ClientError as ex:
        exception_type = ex.response['Error']['Code']
        if exception_type in ['ResourceNotFoundException']:
            print(\\"Remediation completed. Resource policy is now empty.\\")
        else:
            exit(f'ERROR: {exception_type} on get_policy')
    except Exception as e:
        exit(f'Exception while retrieving lambda function policy: {str(e)}')",
              },
              "name": "RemoveLambdaPublicAccess",
              "outputs": Array [
                Object {
                  "Name": "Output",
                  "Selector": "$.Payload.response",
                  "Type": "StringMap",
                },
              ],
            },
          ],
          "outputs": Array [
            "RemoveLambdaPublicAccess.Output",
          ],
          "parameters": Object {
            "AutomationAssumeRole": Object {
              "allowedPattern": "^arn:(aws[a-zA-Z-]*)?:iam::\\\\d{12}:role/[\\\\w+=,.@/-]+$",
              "description": "(Required) The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that allows Systems Manager Automation to perform the actions on your behalf.",
              "type": "String",
            },
            "FunctionName": Object {
              "allowedPattern": "^[a-zA-Z0-9\\\\-_]{1,64}$",
              "type": "String",
            },
          },
          "schemaVersion": "0.3",
        },
        "DocumentType": "Automation",
        "Name": "SHARR-RemoveLambdaPublicAccess",
      },
      "Type": "AWS::SSM::Document",
    },
    "SHARRRemoveVPCDefaultSecurityGroupRulesAutomationDocumentFEAF79A7": Object {
      "Properties": Object {
        "Content": Object {
          "assumeRole": "{{ AutomationAssumeRole }}",
          "description": "### Document name - AWSConfigRemediation-RemoveVPCDefaultSecurityGroupRules

## What does this document do?
This document removes all inbound and outbound rules from the default security group in an Amazon VPC. A default security group is defined as any security group whose name is \`default\`. If the security group ID passed to this automation document belongs to a non-default security group, this document does not perform any changes to the AWS account.

## Input Parameters
* GroupId: (Required) The unique ID of the security group.
* AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.

## Output Parameters
* RemoveRulesAndVerify.Output - Success message or failure exception.
",
          "mainSteps": Array [
            Object {
              "action": "aws:assertAwsResourceProperty",
              "description": "## CheckDefaultSecurityGroup
Verifies that the security group name does match \`default\`. If the group name does match \`default\`, go to the next step: DescribeSecurityGroups.
",
              "inputs": Object {
                "Api": "DescribeSecurityGroups",
                "DesiredValues": Array [
                  "default",
                ],
                "GroupIds": Array [
                  "{{ GroupId }}",
                ],
                "PropertySelector": "$.SecurityGroups[0].GroupName",
                "Service": "ec2",
              },
              "isCritical": true,
              "maxAttempts": 3,
              "name": "CheckDefaultSecurityGroup",
              "nextStep": "RemoveRulesAndVerify",
              "onFailure": "Abort",
              "timeoutSeconds": 20,
            },
            Object {
              "action": "aws:executeScript",
              "description": "## RemoveRulesAndVerify
Removes all rules from the default security group.
## Outputs
* Output: Success message or failure exception.
",
              "inputs": Object {
                "Handler": "handler",
                "InputPayload": Object {
                  "GroupId": "{{ GroupId }}",
                },
                "Runtime": "python3.7",
                "Script": "import boto3
from botocore.exceptions import ClientError
from time import sleep


ec2_client = boto3.client(\\"ec2\\")


def get_permissions(group_id):
    default_group = ec2_client.describe_security_groups(GroupIds=[group_id]).get(\\"SecurityGroups\\")[0]
    return default_group.get(\\"IpPermissions\\"), default_group.get(\\"IpPermissionsEgress\\")


def handler(event, context):
    group_id = event.get(\\"GroupId\\")
    ingress_permissions, egress_permissions = get_permissions(group_id)

    if ingress_permissions:
        ec2_client.revoke_security_group_ingress(GroupId=group_id, IpPermissions=ingress_permissions)
    if egress_permissions:
        ec2_client.revoke_security_group_egress(GroupId=group_id, IpPermissions=egress_permissions)

    ingress_permissions, egress_permissions = get_permissions(group_id)
    if ingress_permissions or egress_permissions:
        raise Exception(f\\"VERIFICATION FAILED. SECURITY GROUP {group_id} NOT CLOSED.\\")

    return {
        \\"output\\": \\"Security group closed successfully.\\"
    }",
              },
              "isCritical": true,
              "isEnd": true,
              "maxAttempts": 3,
              "name": "RemoveRulesAndVerify",
              "onFailure": "Abort",
              "outputs": Array [
                Object {
                  "Name": "Output",
                  "Selector": "$.Payload.output",
                  "Type": "String",
                },
              ],
              "timeoutSeconds": 180,
            },
          ],
          "outputs": Array [
            "RemoveRulesAndVerify.Output",
          ],
          "parameters": Object {
            "AutomationAssumeRole": Object {
              "allowedPattern": "^arn:(aws[a-zA-Z-]*)?:iam::\\\\d{12}:role/[\\\\w+=,.@-]+$",
              "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
              "type": "String",
            },
            "GroupId": Object {
              "allowedPattern": "sg-[a-z0-9]+$",
              "description": "(Required) The unique ID of the security group.",
              "type": "String",
            },
          },
          "schemaVersion": "0.3",
        },
        "DocumentType": "Automation",
        "Name": "SHARR-RemoveVPCDefaultSecurityGroupRules",
      },
      "Type": "AWS::SSM::Document",
    },
    "SHARRRevokeUnrotatedKeysAutomationDocumentB68F3672": Object {
      "Properties": Object {
        "Content": Object {
          "assumeRole": "{{ AutomationAssumeRole }}",
          "description": "### Document Name - SHARR-RevokeUnrotatedKeys

## What does this document do?
This document disables active keys that have not been rotated for more than 90 days. Note that this remediation is **DISRUPTIVE**. It will disabled keys that have been used within the previous 90 days by have not been rotated by using the [UpdateAccessKey API](https://docs.aws.amazon.com/IAM/latest/APIReference/API_UpdateAccessKey.html). Please note, this automation document requires AWS Config to be enabled.

## Input Parameters
* Finding: (Required) Security Hub finding details JSON
* AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.
* MaxCredentialUsageAge: (Optional) Maximum number of days a key is allowed to be unrotated before revoking it. DEFAULT: 90

## Output Parameters
* RevokeUnrotatedKeys.Output
",
          "mainSteps": Array [
            Object {
              "action": "aws:executeScript",
              "description": "## RevokeUnrotatedKeys

This step deactivates IAM user access keys that have not been rotated in more than MaxCredentialUsageAge days
## Outputs
* Output: Success message or failure Exception.
",
              "inputs": Object {
                "Handler": "unrotated_key_handler",
                "InputPayload": Object {
                  "IAMResourceId": "{{ IAMResourceId }}",
                  "MaxCredentialUsageAge": "{{ MaxCredentialUsageAge }}",
                },
                "Runtime": "python3.7",
                "Script": "#!/usr/bin/python
###############################################################################
#  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.         #
#                                                                             #
#  Licensed under the Apache License Version 2.0 (the \\"License\\"). You may not #
#  use this file except in compliance with the License. A copy of the License #
#  is located at                                                              #
#                                                                             #
#      http://www.apache.org/licenses/LICENSE-2.0/                            #
#                                                                             #
#  or in the \\"license\\" file accompanying this file. This file is distributed  #
#  on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, express #
#  or implied. See the License for the specific language governing permis-    #
#  sions and limitations under the License.                                   #
###############################################################################
from datetime import datetime
from datetime import timedelta
import boto3
from botocore.config import Config

boto_config = Config(
    retries ={
        'mode': 'standard'
    }
)

responses = {}
responses[\\"DeactivateUnusedKeysResponse\\"] = []

def str_time_to_datetime(dt_str):
    dt_obj = datetime.strptime(dt_str, '%Y-%m-%dT%H:%M:%SZ').replace(tzinfo=None)
    return dt_obj

def connect_to_iam(boto_config):
    return boto3.client('iam', config=boto_config)

def connect_to_config(boto_config):
    return boto3.client('config', config=boto_config)

def get_user_name(resource_id):
    config_client = connect_to_config(boto_config)
    list_discovered_resources_response = config_client.list_discovered_resources(
        resourceType='AWS::IAM::User',
        resourceIds=[resource_id]
    )
    resource_name = list_discovered_resources_response.get(\\"resourceIdentifiers\\")[0].get(\\"resourceName\\")
    return resource_name

def list_access_keys(user_name, include_inactive=False):
    iam_client = connect_to_iam(boto_config)
    active_keys = []
    keys = iam_client.list_access_keys(UserName=user_name).get(\\"AccessKeyMetadata\\", [])
    for key in keys:
        if include_inactive or key.get('Status') == 'Active':
            active_keys.append(key)
    return active_keys

def deactivate_unused_keys(access_keys, max_credential_usage_age, user_name):
    iam_client = connect_to_iam(boto_config)
    for key in access_keys:
        print(key)
        last_used = iam_client.get_access_key_last_used(AccessKeyId=key.get(\\"AccessKeyId\\")).get(\\"AccessKeyLastUsed\\")
        deactivate = False
        
        days_since_creation = (datetime.now() - str_time_to_datetime(key.get(\\"CreateDate\\"))).days
        last_used_days = (datetime.now() - str_time_to_datetime(last_used.get(\\"LastUsedDate\\"))).days

        print(f'Key {key.get(\\"AccessKeyId\\")} is {days_since_creation} days old and last used {last_used_days} days ago')

        if days_since_creation > max_credential_usage_age:
            deactivate = True
        
        if last_used_days > max_credential_usage_age:
            deactivate = True

        if deactivate:
            deactivate_key(user_name, key.get(\\"AccessKeyId\\"))

def deactivate_key(user_name, access_key):
    iam_client = connect_to_iam(boto_config)
    responses[\\"DeactivateUnusedKeysResponse\\"].append({\\"AccessKeyId\\": access_key, \\"Response\\": iam_client.update_access_key(UserName=user_name, AccessKeyId=access_key, Status=\\"Inactive\\")})

def verify_expired_credentials_revoked(responses, user_name):
    if responses.get(\\"DeactivateUnusedKeysResponse\\"):
        for key in responses.get(\\"DeactivateUnusedKeysResponse\\"):
            key_data = next(filter(lambda x: x.get(\\"AccessKeyId\\") == key.get(\\"AccessKeyId\\"), list_access_keys(user_name, True)))
            if key_data.get(\\"Status\\") != \\"Inactive\\":
                error_message = \\"VERIFICATION FAILED. ACCESS KEY {} NOT DEACTIVATED\\".format(key_data.get(\\"AccessKeyId\\"))
                raise Exception(error_message)
   
    return {
        \\"output\\": \\"Verification of unrotated access keys is successful.\\",
        \\"http_responses\\": responses
    }

def unrotated_key_handler(event, context):
    user_name = get_user_name(event.get(\\"IAMResourceId\\"))
    max_credential_usage_age = int(event.get(\\"MaxCredentialUsageAge\\"))
    access_keys = list_access_keys(user_name)
    deactivate_unused_keys(access_keys, max_credential_usage_age, user_name)
    return verify_expired_credentials_revoked(responses, user_name)",
              },
              "isEnd": true,
              "name": "RevokeUnrotatedKeys",
              "outputs": Array [
                Object {
                  "Name": "Output",
                  "Selector": "$.Payload",
                  "Type": "StringMap",
                },
              ],
              "timeoutSeconds": 600,
            },
          ],
          "outputs": Array [
            "RevokeUnrotatedKeys.Output",
          ],
          "parameters": Object {
            "AutomationAssumeRole": Object {
              "allowedPattern": "^arn:(aws[a-zA-Z-]*)?:iam::\\\\d{12}:role/[\\\\w+=,.@-]+$",
              "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
              "type": "String",
            },
            "IAMResourceId": Object {
              "allowedPattern": "^[\\\\w+=,.@_-]{1,128}$",
              "description": "(Required) IAM resource unique identifier.",
              "type": "String",
            },
            "MaxCredentialUsageAge": Object {
              "allowedPattern": "^(\\\\b([0-9]|[1-8][0-9]|9[0-9]|[1-8][0-9]{2}|9[0-8][0-9]|99[0-9]|[1-8][0-9]{3}|9[0-8][0-9]{2}|99[0-8][0-9]|999[0-9]|10000)\\\\b)$",
              "default": "90",
              "description": "(Required) Maximum number of days within which a credential must be used. The default value is 90 days.",
              "type": "String",
            },
          },
          "schemaVersion": "0.3",
        },
        "DocumentType": "Automation",
        "Name": "SHARR-RevokeUnrotatedKeys",
      },
      "Type": "AWS::SSM::Document",
    },
    "SHARRRevokeUnusedIAMUserCredentialsAutomationDocument12B378F9": Object {
      "Properties": Object {
        "Content": Object {
          "assumeRole": "{{ AutomationAssumeRole }}",
          "description": "### Document Name - AWSConfigRemediation-RevokeUnusedIAMUserCredentials

## What does this document do?
This document revokes unused IAM passwords and active access keys. This document will deactivate expired access keys by using the [UpdateAccessKey API](https://docs.aws.amazon.com/IAM/latest/APIReference/API_UpdateAccessKey.html) and delete expired login profiles by using the [DeleteLoginProfile API](https://docs.aws.amazon.com/IAM/latest/APIReference/API_DeleteLoginProfile.html). Please note, this automation document requires AWS Config to be enabled.

## Input Parameters
* AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.
* IAMResourceId: (Required) IAM resource unique identifier.
* MaxCredentialUsageAge: (Required) Maximum number of days within which a credential must be used. The default value is 90 days.

## Output Parameters
* RevokeUnusedIAMUserCredentialsAndVerify.Output - Success message or failure Exception.

## Note: this is a local copy of the AWS-owned document to enable support in aws-cn and aws-us-gov partitions.
",
          "mainSteps": Array [
            Object {
              "action": "aws:executeScript",
              "description": "## RevokeUnusedIAMUserCredentialsAndVerify
This step deactivates expired IAM User access keys, deletes expired login profiles and verifies credentials were revoked
## Outputs
* Output: Success message or failure Exception.
",
              "inputs": Object {
                "Handler": "unused_iam_credentials_handler",
                "InputPayload": Object {
                  "IAMResourceId": "{{ IAMResourceId }}",
                  "MaxCredentialUsageAge": "{{ MaxCredentialUsageAge }}",
                },
                "Runtime": "python3.7",
                "Script": "import boto3
from datetime import datetime
from datetime import timedelta

iam_client = boto3.client(\\"iam\\")
config_client = boto3.client(\\"config\\")

responses = {}
responses[\\"DeactivateUnusedKeysResponse\\"] = []

def list_access_keys(user_name):
  return iam_client.list_access_keys(UserName=user_name).get(\\"AccessKeyMetadata\\")

def deactivate_key(user_name, access_key):
  responses[\\"DeactivateUnusedKeysResponse\\"].append({\\"AccessKeyId\\": access_key, \\"Response\\": iam_client.update_access_key(UserName=user_name, AccessKeyId=access_key, Status=\\"Inactive\\")})

def deactivate_unused_keys(access_keys, max_credential_usage_age, user_name):
  for key in access_keys:
    last_used = iam_client.get_access_key_last_used(AccessKeyId=key.get(\\"AccessKeyId\\")).get(\\"AccessKeyLastUsed\\")
    if last_used.get(\\"LastUsedDate\\"):
      last_used_date = last_used.get(\\"LastUsedDate\\").replace(tzinfo=None)
      last_used_days = (datetime.now() - last_used_date).days
      if last_used_days >= max_credential_usage_age:
        deactivate_key(user_name, key.get(\\"AccessKeyId\\"))
    else:
      create_date = key.get(\\"CreateDate\\").replace(tzinfo=None)
      days_since_creation = (datetime.now() - create_date).days
      if days_since_creation >= max_credential_usage_age:
        deactivate_key(user_name, key.get(\\"AccessKeyId\\"))

def user_has_login_profile(user_name):
  try:
    iam_client.get_login_profile(UserName=user_name)
  except iam_client.exceptions.NoSuchEntityException:
    return False
  return True

def delete_unused_password(user_name, max_credential_usage_age):
  user = iam_client.get_user(UserName=user_name).get(\\"User\\")
  if user_has_login_profile(user_name) and user.get(\\"PasswordLastUsed\\"):
    password_last_used = user.get(\\"PasswordLastUsed\\").replace(tzinfo=None)
    password_last_used_days = (datetime.now() - password_last_used).days
    if password_last_used_days >= max_credential_usage_age:
      responses[\\"DeleteUnusedPasswordResponse\\"] = iam_client.delete_login_profile(UserName=user_name)

def verify_expired_credentials_revoked(responses, user_name):
  if responses.get(\\"DeactivateUnusedKeysResponse\\"):
    for key in responses.get(\\"DeactivateUnusedKeysResponse\\"):
      key_data = next(filter(lambda x: x.get(\\"AccessKeyId\\") == key.get(\\"AccessKeyId\\"), list_access_keys(user_name)))
      if key_data.get(\\"Status\\") != \\"Inactive\\":
        error_message = \\"VERIFICATION FAILED. ACCESS KEY {} NOT DEACTIVATED\\".format(key_data.get(\\"AccessKeyId\\"))
        raise Exception(error_message)
  if responses.get(\\"DeleteUnusedPasswordResponse\\"):
    try:
      iam_client.get_login_profile(UserName=user_name)
      error_message = \\"VERIFICATION FAILED. IAM USER {} LOGIN PROFILE NOT DELETED\\".format(user_name)
      raise Exception(error_message)
    except iam_client.exceptions.NoSuchEntityException:
      pass
  return {
      \\"output\\": \\"Verification of unused IAM User credentials is successful.\\",
      \\"http_responses\\": responses
  }

def get_user_name(resource_id):
  list_discovered_resources_response = config_client.list_discovered_resources(
      resourceType='AWS::IAM::User',
      resourceIds=[resource_id]
  )
  resource_name = list_discovered_resources_response.get(\\"resourceIdentifiers\\")[0].get(\\"resourceName\\")
  return resource_name

def unused_iam_credentials_handler(event, context):
  iam_resource_id = event.get(\\"IAMResourceId\\")
  user_name = get_user_name(iam_resource_id)
  
  max_credential_usage_age = int(event.get(\\"MaxCredentialUsageAge\\"))
  
  access_keys = list_access_keys(user_name)
  unused_keys = deactivate_unused_keys(access_keys, max_credential_usage_age, user_name)

  delete_unused_password(user_name, max_credential_usage_age)

  return verify_expired_credentials_revoked(responses, user_name)",
              },
              "isEnd": true,
              "name": "RevokeUnusedIAMUserCredentialsAndVerify",
              "outputs": Array [
                Object {
                  "Name": "Output",
                  "Selector": "$.Payload",
                  "Type": "StringMap",
                },
              ],
              "timeoutSeconds": 600,
            },
          ],
          "outputs": Array [
            "RevokeUnusedIAMUserCredentialsAndVerify.Output",
          ],
          "parameters": Object {
            "AutomationAssumeRole": Object {
              "allowedPattern": "^arn:(aws[a-zA-Z-]*)?:iam::\\\\d{12}:role/[\\\\w+=,.@-]+$",
              "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
              "type": "String",
            },
            "IAMResourceId": Object {
              "allowedPattern": "^[\\\\w+=,.@_-]{1,128}$",
              "description": "(Required) IAM resource unique identifier.",
              "type": "String",
            },
            "MaxCredentialUsageAge": Object {
              "allowedPattern": "^(\\\\b([0-9]|[1-8][0-9]|9[0-9]|[1-8][0-9]{2}|9[0-8][0-9]|99[0-9]|[1-8][0-9]{3}|9[0-8][0-9]{2}|99[0-8][0-9]|999[0-9]|10000)\\\\b)$",
              "default": "90",
              "description": "(Required) Maximum number of days within which a credential must be used. The default value is 90 days.",
              "type": "String",
            },
          },
          "schemaVersion": "0.3",
        },
        "DocumentType": "Automation",
        "Name": "SHARR-RevokeUnusedIAMUserCredentials",
      },
      "Type": "AWS::SSM::Document",
    },
    "SHARRSetIAMPasswordPolicyAutomationDocument3455CE75": Object {
      "Properties": Object {
        "Content": Object {
          "assumeRole": "{{ AutomationAssumeRole }}",
          "description": "### Document name - AWSConfigRemediation-SetIAMPasswordPolicy

## What does this document do?
This document sets the AWS Identity and Access Management (IAM) user password policy for the AWS account using the [UpdateAccountPasswordPolicy](https://docs.aws.amazon.com/IAM/latest/APIReference/API_UpdateAccountPasswordPolicy.html) API.

## Input Parameters
* AllowUsersToChangePassword: (Optional) Allows all IAM users in your account to use the AWS Management Console to change their own passwords.
* HardExpiry: (Optional) Prevents IAM users from setting a new password after their password has expired.
* MaxPasswordAge: (Optional) The number of days that an IAM user password is valid.
* MinimumPasswordLength: (Optional) The minimum number of characters allowed in an IAM user password.
* PasswordReusePrevention: (Optional) Specifies the number of previous passwords that IAM users are prevented from reusing.
* RequireLowercaseCharacters: (Optional) Specifies whether IAM user passwords must contain at least one lowercase character from the ISO basic Latin alphabet (a to z).
* RequireNumbers: (Optional) Specifies whether IAM user passwords must contain at least one numeric character (0 to 9).
* RequireSymbols: (Optional) pecifies whether IAM user passwords must contain at least one of the following non-alphanumeric characters :! @ \\\\# $ % ^ * ( ) _ + - = [ ] { } | '
* RequireUppercaseCharacters: (Optional) Specifies whether IAM user passwords must contain at least one uppercase character from the ISO basic Latin alphabet (A to Z).
* AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.
## Output Parameters
* UpdateAndVerifyIamUserPasswordPolicy.Output
",
          "mainSteps": Array [
            Object {
              "action": "aws:executeScript",
              "description": "## UpdateAndVerifyIamUserPasswordPolicy
Sets or updates the AWS account password policy using input parameters using UpdateAccountPasswordPolicy API.
Verify AWS account password policy using GetAccountPasswordPolicy API.
## Outputs
* Output: Success message with HTTP Response from GetAccountPasswordPolicy API call or failure exception.
",
              "inputs": Object {
                "Handler": "update_and_verify_iam_user_password_policy",
                "InputPayload": Object {
                  "AllowUsersToChangePassword": "{{ AllowUsersToChangePassword }}",
                  "HardExpiry": "{{ HardExpiry }}",
                  "MaxPasswordAge": "{{ MaxPasswordAge }}",
                  "MinimumPasswordLength": "{{ MinimumPasswordLength }}",
                  "PasswordReusePrevention": "{{ PasswordReusePrevention }}",
                  "RequireLowercaseCharacters": "{{ RequireLowercaseCharacters }}",
                  "RequireNumbers": "{{ RequireNumbers }}",
                  "RequireSymbols": "{{ RequireSymbols }}",
                  "RequireUppercaseCharacters": "{{ RequireUppercaseCharacters }}",
                },
                "Runtime": "python3.7",
                "Script": "import boto3


def update_and_verify_iam_user_password_policy(event, context):
    iam_client = boto3.client('iam')

    try:
        params = dict()
        params[\\"AllowUsersToChangePassword\\"] = event[\\"AllowUsersToChangePassword\\"]
        if \\"HardExpiry\\" in event:
            params[\\"HardExpiry\\"] = event[\\"HardExpiry\\"]
        if event[\\"MaxPasswordAge\\"]:
            params[\\"MaxPasswordAge\\"] = event[\\"MaxPasswordAge\\"]
        if event[\\"PasswordReusePrevention\\"]:
            params[\\"PasswordReusePrevention\\"] = event[\\"PasswordReusePrevention\\"]
        params[\\"MinimumPasswordLength\\"] = event[\\"MinimumPasswordLength\\"]
        params[\\"RequireLowercaseCharacters\\"] = event[\\"RequireLowercaseCharacters\\"]
        params[\\"RequireNumbers\\"] = event[\\"RequireNumbers\\"]
        params[\\"RequireSymbols\\"] = event[\\"RequireSymbols\\"]
        params[\\"RequireUppercaseCharacters\\"] = event[\\"RequireUppercaseCharacters\\"]

        update_api_response = iam_client.update_account_password_policy(**params)

        # Verifies IAM Password Policy configuration for AWS account using GetAccountPasswordPolicy() api call.
        response = iam_client.get_account_password_policy()
        if all([response[\\"PasswordPolicy\\"][\\"AllowUsersToChangePassword\\"] == event[\\"AllowUsersToChangePassword\\"],
                response[\\"PasswordPolicy\\"][\\"MinimumPasswordLength\\"] == event[\\"MinimumPasswordLength\\"],
                response[\\"PasswordPolicy\\"][\\"RequireLowercaseCharacters\\"] == event[\\"RequireLowercaseCharacters\\"],
                response[\\"PasswordPolicy\\"][\\"RequireNumbers\\"] == event[\\"RequireNumbers\\"],
                response[\\"PasswordPolicy\\"][\\"RequireUppercaseCharacters\\"] == event[\\"RequireUppercaseCharacters\\"],
                ((response[\\"PasswordPolicy\\"][\\"HardExpiry\\"] == event[\\"HardExpiry\\"]) if \\"HardExpiry\\" in event else True),
                ((response[\\"PasswordPolicy\\"][\\"MaxPasswordAge\\"] == event[\\"MaxPasswordAge\\"]) if event[\\"MaxPasswordAge\\"] else True),
                ((response[\\"PasswordPolicy\\"][\\"PasswordReusePrevention\\"] == event[\\"PasswordReusePrevention\\"]) if event[\\"PasswordReusePrevention\\"] else True)]):
            return {
                \\"output\\": {
                    \\"Message\\": \\"AWS Account Password Policy setting is SUCCESSFUL.\\",
                    \\"UpdatePolicyHTTPResponse\\": update_api_response,
                    \\"GetPolicyHTTPResponse\\": response
                }
            }
        raise Exception(\\"VERIFICATION FAILED. AWS ACCOUNT PASSWORD POLICY NOT UPDATED.\\")

    except iam_client.exceptions.NoSuchEntityException:
        raise Exception(\\"VERIFICATION FAILED. UNABLE TO UPDATE AWS ACCOUNT PASSWORD POLICY.\\")",
              },
              "isEnd": true,
              "name": "UpdateAndVerifyIamUserPasswordPolicy",
              "outputs": Array [
                Object {
                  "Name": "Output",
                  "Selector": "$.Payload.output",
                  "Type": "StringMap",
                },
              ],
              "timeoutSeconds": 600,
            },
          ],
          "outputs": Array [
            "UpdateAndVerifyIamUserPasswordPolicy.Output",
          ],
          "parameters": Object {
            "AllowUsersToChangePassword": Object {
              "default": false,
              "description": "(Optional) Allows all IAM users in your AWS account to use the AWS Management Console to change their own passwords.",
              "type": "Boolean",
            },
            "AutomationAssumeRole": Object {
              "allowedPattern": "^arn:(aws[a-zA-Z-]*)?:iam::\\\\d{12}:role/[\\\\w+=,.@-]+",
              "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
              "type": "String",
            },
            "HardExpiry": Object {
              "default": false,
              "description": "(Optional) Prevents IAM users from setting a new password after their password has expired.",
              "type": "Boolean",
            },
            "MaxPasswordAge": Object {
              "allowedPattern": "^\\\\d{0,3}$|^10[0-8]\\\\d$|^109[0-5]$",
              "default": 0,
              "description": "(Optional) The number of days that an IAM user password is valid.",
              "type": "Integer",
            },
            "MinimumPasswordLength": Object {
              "allowedPattern": "^[6-9]$|^[1-9]\\\\d$|^1[01]\\\\d$|^12[0-8]$",
              "default": 6,
              "description": "(Optional) The minimum number of characters allowed in an IAM user password.",
              "type": "Integer",
            },
            "PasswordReusePrevention": Object {
              "allowedPattern": "^\\\\d{0,1}$|^1\\\\d$|^2[0-4]$",
              "default": 0,
              "description": "(Optional) Specifies the number of previous passwords that IAM users are prevented from reusing.",
              "type": "Integer",
            },
            "RequireLowercaseCharacters": Object {
              "default": false,
              "description": "(Optional) Specifies whether IAM user passwords must contain at least one lowercase character from the ISO basic Latin alphabet (a to z).",
              "type": "Boolean",
            },
            "RequireNumbers": Object {
              "default": false,
              "description": "(Optional) Specifies whether IAM user passwords must contain at least one numeric character (0 to 9).",
              "type": "Boolean",
            },
            "RequireSymbols": Object {
              "default": false,
              "description": "(Optional) Specifies whether IAM user passwords must contain at least one of the following non-alphanumeric characters :! @ \\\\# $ % ^ * ( ) _ + - = [ ] { } | '.",
              "type": "Boolean",
            },
            "RequireUppercaseCharacters": Object {
              "default": false,
              "description": "(Optional) Specifies whether IAM user passwords must contain at least one uppercase character from the ISO basic Latin alphabet (A to Z).",
              "type": "Boolean",
            },
          },
          "schemaVersion": "0.3",
        },
        "DocumentType": "Automation",
        "Name": "SHARR-SetIAMPasswordPolicy",
      },
      "Type": "AWS::SSM::Document",
    },
    "SHARRSetSSLBucketPolicyAutomationDocument5C7D5BF3": Object {
      "Properties": Object {
        "Content": Object {
          "assumeRole": "{{ AutomationAssumeRole }}",
          "description": "### Document name - SHARR-SetSSLBucketPolicy

## What does this document do?
This document adds a bucket policy to require transmission over HTTPS for the given S3 bucket by adding a policy statement to the bucket policy.

## Input Parameters
* AutomationAssumeRole: (Required) The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that allows Systems Manager Automation to perform the actions on your behalf.
* BucketName: (Required) Name of the bucket to modify.
* AccountId: (Required) Account to which the bucket belongs

## Output Parameters

* Remediation.Output - stdout messages from the remediation

## Security Standards / Controls
* AFSBP v1.0.0: S3.5
* CIS v1.2.0:   n/a
* PCI:          S3.5
",
          "mainSteps": Array [
            Object {
              "action": "aws:executeScript",
              "inputs": Object {
                "Handler": "add_ssl_bucket_policy",
                "InputPayload": Object {
                  "accountid": "{{AccountId}}",
                  "bucket": "{{BucketName}}",
                },
                "Runtime": "python3.7",
                "Script": "#!/usr/bin/python
###############################################################################
#  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.         #
#                                                                             #
#  Licensed under the Apache License Version 2.0 (the \\"License\\"). You may not #
#  use this file except in compliance with the License. A copy of the License #
#  is located at                                                              #
#                                                                             #
#      http://www.apache.org/licenses/LICENSE-2.0/                            #
#                                                                             #
#  or in the \\"license\\" file accompanying this file. This file is distributed  #
#  on an \\"AS IS\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, express #
#  or implied. See the License for the specific language governing permis-    #
#  sions and limitations under the License.                                   #
###############################################################################

import json
import boto3
from botocore.config import Config
from botocore.exceptions import ClientError

boto_config = Config(
    retries = {
            'mode': 'standard',
            'max_attempts': 10
        }
    )

def connect_to_s3():
    return boto3.client('s3', config=boto_config)

def policy_to_add(bucket):
    return {
        \\"Sid\\": \\"AllowSSLRequestsOnly\\",
        \\"Action\\": \\"s3:*\\",
        \\"Effect\\": \\"Deny\\",
        \\"Resource\\": [
            f'arn:aws:s3:::{bucket}',
            f'arn:aws:s3:::{bucket}/*'
        ],
        \\"Condition\\": {
            \\"Bool\\": {
                    \\"aws:SecureTransport\\": \\"false\\"
            }
        },
        \\"Principal\\": \\"*\\"
    }
def new_policy():
    return {
        \\"Id\\": \\"BucketPolicy\\",
        \\"Version\\": \\"2012-10-17\\",
        \\"Statement\\": []
    }

def add_ssl_bucket_policy(event, context):
    bucket_name = event['bucket']
    account_id = event['accountid']
    s3 = connect_to_s3()
    bucket_policy = {}
    try:
        existing_policy = s3.get_bucket_policy(
            Bucket=bucket_name,
            ExpectedBucketOwner=account_id
        )
        bucket_policy = json.loads(existing_policy['Policy'])
    except ClientError as ex:
        exception_type = ex.response['Error']['Code']
        # delivery channel already exists - return
        if exception_type not in [\\"NoSuchBucketPolicy\\"]:
            exit(f'ERROR: Boto3 s3 ClientError: {exception_type} - {str(ex)}')
    except Exception as e:
        exit(f'ERROR getting bucket policy for {bucket_name}: {str(e)}')

    if not bucket_policy:
        bucket_policy = new_policy()

    print(f'Existing policy: {bucket_policy}')
    bucket_policy['Statement'].append(policy_to_add(bucket_name))

    try:
        result = s3.put_bucket_policy(
            Bucket=bucket_name,
            Policy=json.dumps(bucket_policy, indent=4, default=str),
            ExpectedBucketOwner=account_id
        )
        print(result)
    except ClientError as ex:
        exception_type = ex.response['Error']['Code']
        exit(f'ERROR: Boto3 s3 ClientError: {exception_type} - {str(ex)}')
    except Exception as e:
        exit(f'ERROR putting bucket policy for {bucket_name}: {str(e)}')

    print(f'New policy: {bucket_policy}')",
              },
              "name": "Remediation",
              "outputs": Array [
                Object {
                  "Name": "Output",
                  "Selector": "$.Payload.response",
                  "Type": "StringMap",
                },
              ],
            },
          ],
          "outputs": Array [
            "Remediation.Output",
          ],
          "parameters": Object {
            "AccountId": Object {
              "allowedPattern": "^[0-9]{12}$",
              "description": "Account ID of the account for the finding",
              "type": "String",
            },
            "AutomationAssumeRole": Object {
              "allowedPattern": "^arn:(aws[a-zA-Z-]*)?:iam::\\\\d{12}:role/[\\\\w+=,.@/-]+$",
              "description": "(Required) The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that allows Systems Manager Automation to perform the actions on your behalf.",
              "type": "String",
            },
            "BucketName": Object {
              "allowedPattern": "(?=^.{3,63}$)(?!^(\\\\d+\\\\.)+\\\\d+$)(^(([a-z0-9]|[a-z0-9][a-z0-9\\\\-]*[a-z0-9])\\\\.)*([a-z0-9]|[a-z0-9][a-z0-9\\\\-]*[a-z0-9])$)",
              "description": "Name of the bucket to have a policy added",
              "type": "String",
            },
          },
          "schemaVersion": "0.3",
        },
        "DocumentType": "Automation",
        "Name": "SHARR-SetSSLBucketPolicy",
      },
      "Type": "AWS::SSM::Document",
    },
  },
}
`;
